<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Dart Language Tutorial</title>
  <link rel="icon" type="image/x-icon" href="https://img.icons8.com/color/48/dart.png">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #F8F9FA;
      color: #343A40;
    }

    .sidebar {
      background-color: #E9ECEF;
      /* Light Gray for sidebar differentiation */
      border-right: 1px solid #DEE2E6;
    }

    .sidebar-link {
      color: #343A40;
      transition: background-color 0.2s, color 0.2s;
    }

    .sidebar-link:hover,
    .sidebar-link.active {
      background-color: #4A90E2;
      color: white;
    }

    .content-section h1,
    .content-section h2,
    .content-section h3,
    .content-section h4 {
      color: #343A40;
      /* Darker text for headers */
      margin-bottom: 0.75rem;
      margin-top: 1.5rem;
    }

    .content-section h1 {
      font-size: 1.875rem;
      font-weight: 600;
      border-bottom: 2px solid #4A90E2;
      padding-bottom: 0.5rem;
    }

    .content-section h2 {
      font-size: 1.5rem;
      font-weight: 600;
    }

    .content-section h3 {
      font-size: 1.25rem;
      font-weight: 600;
    }

    .content-section h4 {
      font-size: 1.1rem;
      font-weight: 600;
      color: #4A90E2;
      margin-top: 1rem;
    }

    .code-block {
      background-color: #2d3748;
      /* Darker background for code */
      color: #e2e8f0;
      /* Lighter text for code */
      border: 1px solid #4a5568;
      /* Slightly lighter border */
      border-radius: 0.375rem;
      padding: 1rem;
      margin-top: 0.5rem;
      margin-bottom: 1rem;
      overflow-x: auto;
      position: relative;
    }

    .code-block pre {
      margin: 0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .code-block code {
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
      font-size: 0.875rem;
    }

    .copy-button {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      background-color: #4A5568;
      /* Darker gray */
      color: white;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      border-radius: 0.25rem;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .copy-button:hover {
      background-color: #2C5282;
      /* Darker blue */
    }

    .practice-questions,
    .real-life-example,
    .exercise-block {
      background-color: #E0E7FF;
      /* Lighter blue for practice questions */
      border: 1px solid #C7D2FE;
      border-radius: 0.375rem;
      padding: 1rem;
      margin-top: 1rem;
      margin-bottom: 1.5rem;
    }

    .practice-questions h3,
    .real-life-example h4,
    .exercise-block h4 {
      color: #3730A3;
      /* Darker blue for question headers */
      margin-top: 0;
    }

    .exercise-block h4 {
      margin-bottom: 0.5rem;
    }

    .chart-container {
      position: relative;
      width: 100%;
      max-width: 700px;
      /* Max width for the chart */
      margin-left: auto;
      margin-right: auto;
      height: 350px;
      /* Default height */
      max-height: 400px;
      /* Max height */
      padding: 1rem;
      background-color: white;
      border-radius: 0.375rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    @media (min-width: 768px) {

      /* md */
      .chart-container {
        height: 400px;
      }
    }

    .tooltip {
      position: absolute;
      background-color: #333;
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 100;
    }

    .note {
      background-color: #fffbeb;
      /* Light yellow */
      border-left: 4px solid #facc15;
      /* Yellow border */
      padding: 0.75rem;
      margin-top: 1rem;
      margin-bottom: 1rem;
      border-radius: 0.25rem;
    }

    .note p {
      margin: 0;
    }
  </style>
</head>

<body class="flex h-screen overflow-hidden">
  <aside class="sidebar w-64 h-full overflow-y-auto p-4 space-y-2">
    <h1 class="text-xl font-semibold text-gray-700 mb-4">Dart Tutorial</h1>
    <nav id="module-navigation">
      <a href="#" class="block py-2 px-3 rounded sidebar-link" data-module="overview">Overview</a>
      <a href="#" class="block py-2 px-3 rounded sidebar-link" data-module="module0">Module 0: Getting Started</a>
      <a href="#" class="block py-2 px-3 rounded sidebar-link" data-module="module1">Module 1: Conditions & Loops</a>
      <a href="#" class="block py-2 px-3 rounded sidebar-link" data-module="module2">Module 2: Collections (Lists & Sets
        Intro)</a>
      <a href="#" class="block py-2 px-3 rounded sidebar-link" data-module="module3">Module 3: Collections (Sets &
        Maps)</a>
      <a href="#" class="block py-2 px-3 rounded sidebar-link" data-module="module4">Module 4: Functions</a>
      <a href="#" class="block py-2 px-3 rounded sidebar-link" data-module="module5">Module 5: File & Exception
        Handling</a>
      <a href="#" class="block py-2 px-3 rounded sidebar-link" data-module="module6">Module 6: Master on Object-Oriented
        Programming (Part 1)</a>
      <a href="#" class="block py-2 px-3 rounded sidebar-link" data-module="module7">Module 7: Master on Object-Oriented
        Programming (Part 2)</a>
      <a href="#" class="block py-2 px-3 rounded sidebar-link" data-module="module8">Module 8: Advanced Object-Oriented
        Programming and Design</a>
      <a href="#" class="block py-2 px-3 rounded sidebar-link" data-module="module9">Module 9: Dart Asynchronous
        Programming</a>
      <a href="#" class="block py-2 px-3 rounded sidebar-link" data-module="module10">Module 10: Advanced Debugging</a>
      <a href="#" class="block py-2 px-3 rounded sidebar-link" data-module="nextsteps">What's Next?</a>
    </nav>
  </aside>

  <main class="flex-1 h-full overflow-y-auto p-6 md:p-8 lg:p-10">
    <div id="content-area">
    </div>
    <div id="tooltip" class="tooltip">Copied!</div>
  </main>

  <script>
    const tutorialData = {
      overview: {
        title: "Welcome to the Interactive Dart Tutorial!",
        introduction: "This interactive guide corresponds to the Dart Language Tutorial modules. Use the sidebar to navigate through the modules and topics. Below is a conceptual chart showing the number of main sections covered in each module. The primary goal of this application is to make the tutorial content easily explorable and understandable.",
        content: `
                <p class="mb-4">The tutorial is designed to be easy to understand, especially if English is your second language. We will cover topics in depth with clear explanations, examples, and practice questions to help you master Dart.</p>
                <div class="chart-container my-8">
                    <canvas id="sectionsChart"></canvas>
                </div>
                <p>Click on a module in the sidebar to begin your learning journey!</p>
            `
      },
      module0: { // Corresponds to PDF Module 0
        title: "Module 0: Getting Started with Dart",
        introduction: "Today, we'll cover the absolute basics: what Dart is, how to set it up, write your first program, and understand fundamental concepts like variables, basic data types, operators, and comments. This section translates the key points from Module 0 of the provided Dart tutorial.",
        sections: [
          {
            id: "module0-intro", title: "Module 0: The Very Basics",
            content: `
                        <p>Before we jump into \"Conditions and Loops\", let's quickly cover some absolute basics that are essential. Think of these as the building blocks.</p>`
          },
          {
            id: "first-program", title: "0.1 Your First Dart Program: \"Hello, World!\"",
            content: `
                        <p>Every programming journey starts with printing \"Hello, World!\". In Dart, it's simple:</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  print('Hello, World!');
}</code></pre>
                        </div>
                        <p><strong>Explanation:</strong></p>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>void main() { ... }</code>: This is the main entry point of every Dart application. Your program starts running from here. <code>void</code> means this function doesn't return any value.</li>
                            <li><code>print('Hello, World!');</code>: This line tells the computer to display the text \"Hello, World!\" on the screen. Text in programming is often called a \"string\" and is enclosed in single quotes (<code>'...'</code>) or double quotes (<code>"..."</code>).</li>
                            <li><code>;</code> (semicolon): Most lines of code in Dart end with a semicolon. It tells Dart that the statement is complete.</li>
                        </ul>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Imagine <code>main()</code> is the main door to your house. When someone wants to start something in your house, they enter through the main door. <code>print()</code> is like you speaking out loud.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Go to DartPad. Clear any existing code, type the \"Hello, World!\" program above, and click \"Run\". See what happens! Try changing the message to \"Hello, [Your Name]!\".</p>
                        </div>`
          },
          {
            id: "variables", title: "0.2 Variables: Storing Information",
            content: `
                        <p>Variables are like containers or boxes where you can store information (data) that your program can use. Each container has a name.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  // Declaring a variable and initializing it
  String name = 'Alice'; // Stores text
  int age = 30;         // Stores whole numbers
  double price = 19.99;  // Stores numbers with decimals
  bool isLoggedIn = true; // Stores true or false

  print('Name: \$name');
  print('Age: \$age');
  print('Price: \$price');
  print('Logged In: \$isLoggedIn');

  // You can change the value of a variable (if it's not 'final' or 'const')
  age = 31;
  print('New Age: \$age');
}</code></pre>
                        </div>
                        <p><strong>Key Data Types mentioned:</strong></p>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>String</code>: Used for text.</li>
                            <li><code>int</code>: Used for whole numbers (integers).</li>
                            <li><code>double</code>: Used for numbers with decimal points.</li>
                            <li><code>bool</code>: Used for true/false values (Booleans).</li>
                            <li><code>\$variableName</code> inside a string: This is called string interpolation. It's an easy way to put the value of a variable inside a string.</li>
                        </ul>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Think of variables like labeled jars in your kitchen. One jar labeled \"Sugar\" holds sugar (an <code>int</code> for grams, or a <code>String</code> for \"Sugar\"). Another labeled \"Coffee\" holds coffee.</p>
                        </div>
                        <h4>Keywords <code>var</code>, <code>final</code>, and <code>const</code>:</h4>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>var</code>: Dart can often figure out the type of the variable automatically if you use <code>var</code>.
                                <div class="code-block">
                                    <button class="copy-button">Copy</button>
                                    <pre><code>var myName = 'Bob'; // Dart knows myName is a String
var myAge = 25;   // Dart knows myAge is an int</code></pre>
                                </div>
                            </li>
                            <li><code>final</code>: If you don't want a variable's value to change after it's set once, use <code>final</code>. It's like writing on a box with a permanent marker.
                                <div class="code-block">
                                    <button class="copy-button">Copy</button>
                                    <pre><code>final String country = 'Canada';
// country = 'USA'; // This would cause an error!</code></pre>
                                </div>
                            </li>
                            <li><code>const</code>: Use <code>const</code> for variables whose values are known at compile-time (before the program even runs) and will never change. These are even more strict than <code>final</code>.
                                <div class="code-block">
                                    <button class="copy-button">Copy</button>
                                    <pre><code>const double PI = 3.14159;</code></pre>
                                </div>
                            </li>
                        </ul>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Create variables for your favorite color (String), your birth year (int), and whether you like pizza (bool). Print them out.</p>
                        </div>`
          },
          {
            id: "operators-basic", title: "0.3 Basic Operators: Doing Calculations and Comparisons",
            content: `
                        <p>Operators are special symbols that perform operations on variables and values.</p>
                        <h4>a. Arithmetic Operators (Math):</h4>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>+</code> (add)</li>
                            <li><code>-</code> (subtract)</li>
                            <li><code>*</code> (multiply)</li>
                            <li><code>/</code> (divide - always results in a double)</li>
                            <li><code>~/</code> (integer divide - results in an int, discards remainder)</li>
                            <li><code>%</code> (modulo - gives the remainder of a division)</li>
                        </ul>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  int a = 10;
  int b = 3;

  print('a + b = \${a + b}');   // Output: 13
  print('a - b = \${a - b}');   // Output: 7
  print('a * b = \${a * b}');   // Output: 30
  print('a / b = \${a / b}');   // Output: 3.333...
  print('a ~/ b = \${a ~/ b}'); // Output: 3
  print('a % b = \${a % b}');   // Output: 1 (10 divided by 3 is 3 with a remainder of 1)
}</code></pre>
                        </div>
                        <h4>b. Comparison Operators (Comparing values):</h4>
                        <p>These operators compare two values and return a <code>bool</code> (true or false).</p>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>==</code> (equal to)</li>
                            <li><code>!=</code> (not equal to)</li>
                            <li><code>></code> (greater than)</li>
                            <li><code><</code> (less than)</li>
                            <li><code>>=</code> (greater than or equal to)</li>
                            <li><code><=</code> (less than or equal to)</li>
                        </ul>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  int x = 5;
  int y = 10;

  print('x == y: \${x == y}'); // Output: false
  print('x != y: \${x != y}'); // Output: true
  print('x > y: \${x > y}');   // Output: false
  print('x < y: \${x < y}');   // Output: true
}</code></pre>
                        </div>
                        <h4>c. Logical Operators (Combining true/false conditions):</h4>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>&&</code> (logical AND - both sides must be true for the result to be true)</li>
                            <li><code>||</code> (logical OR - at least one side must be true for the result to be true)</li>
                            <li><code>!</code> (logical NOT - reverses the boolean value; <code>!true</code> is false, <code>!false</code> is true)</li>
                        </ul>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  bool isSunny = true;
  bool isWarm = false;

  print('Sunny AND Warm: \${isSunny && isWarm}'); // Output: false
  print('Sunny OR Warm: \${isSunny || isWarm}');  // Output: true
  print('NOT Sunny: \${!isSunny}');             // Output: false
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Examples:</h4>
                            <p><strong>Arithmetic:</strong> You buy 2 apples (*) at \$0.50 each, and 1 banana (+) at \$0.30. Total cost = (2 * 0.50) + 0.30.</p>
                            <p><strong>Comparison:</strong> Is your age (myAge) greater than (>) 18? This helps decide if you can vote.</p>
                            <p><strong>Logical:</strong> To go to the beach, it must be sunny (isSunny) AND you must have free time (hasFreeTime).</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <ol class="list-decimal list-inside space-y-2">
                                <li>Calculate the area of a rectangle with length 5 and width 3. Store the result in a variable and print it.</li>
                                <li>Declare two numbers. Check if the first number is greater than the second and if the first number is even. Print the results. (Hint: a number is even if <code>number % 2 == 0</code>).</li>
                            </ol>
                        </div>`
          },
          {
            id: "comments", title: "0.4 Comments: Explaining Your Code",
            content: `
                        <p>Comments are notes in your code that Dart ignores. They are for humans to read and understand the code better.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  // This is a single-line comment. It explains the next line.
  String greeting = 'Hello';

  /*
   This is a
   multi-line comment.
   It can span several lines.
  */
  int count = 10; // This is also a single-line comment at the end of a line.

  /// This is a documentation comment.
  /// It's used to generate documentation for your code.
  /// We'll learn more about this later.
  print('\$greeting, you have \$count new messages.');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Comments are like sticky notes you put on a document to remind yourself or explain something to others.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Go back to your previous exercises and add comments to explain what each part of your code does.</p>
                        </div>`
          },
          {
            id: "module0-practice", title: "Module 0: Practice Questions Review",
            isPractice: true,
            content: `
                        <ol class="list-decimal list-inside space-y-2">
                            <li><strong>My Information Program:</strong> Create <code>my_info.dart</code>. Store your name, age, favorite color in variables. Print them in a sentence using string interpolation. Add comments explaining each variable.</li>
                            <li><strong>Variable Types:</strong> Declare <code>city</code> with <code>var</code>. Print <code>city.runtimeType</code>. Declare <code>temperature</code> as <code>double</code>. Declare a <code>final</code> variable <code>country</code>. Declare a <code>const</code> variable <code>gravity</code> (9.8). Try to reassign <code>country</code> and <code>gravity</code> and observe the error.</li>
                            <li><strong>Arithmetic Challenge:</strong> Calculate the total cost of 3 items priced at \$2.50, \$1.75, and \$5.00. Apply a 10% discount. Print the final price.</li>
                            <li><strong>Logical Check:</strong> Write a program that checks if a number is positive AND even. Print the result.</li>
                        </ol>`
          }
        ]
      },
      module1: { // Corresponds to PDF Module 1
        title: "Module 1: Conditions and Loops",
        introduction: "This module is about controlling the flow of your program. Sometimes you want to run code only if a certain condition is true. Other times, you want to repeat a piece of code multiple times. This covers Module 1 from the PDF.",
        sections: [
          {
            id: "control-flow-use-cases", title: "1.1 Control Flow Practical Use Cases",
            content: `
                        <h4>What is Control Flow?</h4>
                        <p>Imagine you're giving directions to someone. You might say, "Go straight. If you see a red building, turn right. Otherwise, continue straight. Repeat knocking on the door until someone opens."</p>
                        <p>These "if/otherwise" and "repeat until" are control flow statements. They control the path or "flow" of execution in your program.</p>
                        <h4>Why is it useful?</h4>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><strong>Making Decisions:</strong> Run different code based on different situations (e.g., if a user is logged in, show their profile; otherwise, show a login button).</li>
                            <li><strong>Repeating Tasks:</strong> Perform an action multiple times without writing the same code over and over (e.g., process all items in a shopping cart).</li>
                            <li><strong>Responding to Input:</strong> Change behavior based on user input or other changing data.</li>
                        </ul>`
          },
          {
            id: "conditions-loops-review", title: "1.2 Conditions and Loops Review",
            content: `
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><strong>Conditions (Conditional Statements):</strong> These allow your program to make decisions. The main ones are <code>if</code>, <code>if-else</code>, and <code>switch</code>. They check if a condition is true or false and execute code accordingly.</li>
                            <li><strong>Loops (Iterative Statements):</strong> These allow your program to repeat a block of code. The main ones are <code>for</code>, <code>while</code>, and <code>do-while</code>.</li>
                        </ul>`
          },
          {
            id: "if-statement", title: "1.3 if Statement",
            content: `
                        <p>The <code>if</code> statement executes a block of code only if a specified condition is true.</p>
                        <p><strong>Syntax:</strong></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>if (condition) {
  // Code to execute if the condition is true
}</code></pre>
                        </div>
                        <p><strong>Example:</strong></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  int age = 20;
  if (age >= 18) {
    print('You are an adult and can vote.');
  }
  print('Program finished.');
}</code></pre>
                        </div>
                        <p><strong>Explanation:</strong> The code <code>print('You are an adult and can vote.');</code> will only run if the age is 18 or greater. <code>Program finished.</code> will always print.</p>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>If it is raining (condition), then you take an umbrella (action).</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Write a program that defines a variable <code>temperature</code>. If the temperature is greater than 25, print "It's a hot day!".</p>
                        </div>`
          },
          {
            id: "if-else-statement", title: "1.4 if-else Statement",
            content: `
                        <p>The <code>if-else</code> statement executes one block of code if the condition is true, and another block of code if the condition is false.</p>
                        <p><strong>Syntax:</strong></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>if (condition) {
  // Code to execute if the condition is true
} else {
  // Code to execute if the condition is false
}</code></pre>
                        </div>
                        <p><strong>Example:</strong></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  int score = 75;
  if (score >= 50) {
    print('Congratulations! You passed.');
  } else {
    print('Sorry, you failed. Try again.');
  }
}</code></pre>
                        </div>
                        <p><strong>Explanation:</strong> If <code>score</code> is 50 or more, it prints "Congratulations! You passed.". Otherwise (if <code>score</code> is less than 50), it prints "Sorry, you failed. Try again.".</p>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>If you have a ticket (condition), then you can enter the cinema. Else (if you don't have a ticket), you cannot enter.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Write a program that checks if a number is even or odd. If it's even, print "The number is even." Otherwise, print "The number is odd." (Hint: a number is even if <code>number % 2 == 0</code>).</p>
                        </div>`
          },
          {
            id: "nested-if-else", title: "1.5 Nested if-else",
            content: `
                        <p>You can put <code>if-else</code> statements inside other <code>if-else</code> statements. This is called nesting.</p>
                        <p><strong>Example:</strong></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  int age = 25;
  bool hasLicense = true;

  if (age >= 18) {
    print('You are old enough to drive.');
    if (hasLicense) {
      print('And you have a license! You can drive.');
    } else {
      print('But you do not have a license yet. You cannot drive legally.');
    }
  } else {
    print('You are too young to drive.');
  }
}</code></pre>
                        </div>
                        <p><strong>Explanation:</strong> First, it checks the age. If the age is 18 or more, it then checks if <code>hasLicense</code> is true.</p>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>To get a loan:<br>
                            If your income is above a certain amount,<br>
                            &nbsp;&nbsp;then if your credit score is good,<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;then you get the loan.<br>
                            &nbsp;&nbsp;Else (credit score not good),<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;you don't get the loan.<br>
                            Else (income not enough),<br>
                            &nbsp;&nbsp;you don't get the loan.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Define two numbers, <code>num1</code> and <code>num2</code>.<br>
                            First, check if <code>num1</code> is greater than <code>num2</code>.<br>
                            If it is, then check if <code>num1</code> is also an even number. Print appropriate messages for each condition.<br>
                            If <code>num1</code> is not greater than <code>num2</code>, print a message saying that.</p>
                        </div>`
          },
          {
            id: "else-if-ladder", title: "1.6 else-if (Ladder)",
            content: `
                        <p>Used when you have multiple conditions to check in sequence. It's like a ladder of choices.</p>
                        <p><strong>Syntax:</strong></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>if (condition1) {
  // Code for condition1
} else if (condition2) {
  // Code for condition2
} else if (condition3) {
  // Code for condition3
} else {
  // Code if none of the above conditions are true
}</code></pre>
                        </div>
                        <p><strong>Example:</strong></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  int marks = 75;

  if (marks >= 90) {
    print('Grade: A+');
  } else if (marks >= 80) {
    print('Grade: A');
  } else if (marks >= 70) {
    print('Grade: B');
  } else if (marks >= 60) {
    print('Grade: C');
  } else {
    print('Grade: F (Fail)');
  }
}</code></pre>
                        </div>
                        <p><strong>Explanation:</strong> Dart checks the conditions one by one from top to bottom. As soon as it finds a true condition, it executes the corresponding code block and skips the rest of the <code>else-if</code> ladder. The final <code>else</code> is optional and runs if none of the <code>if</code> or <code>else if</code> conditions were true.</p>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Choosing what to wear based on weather:<br>
                            If it's very cold, wear a heavy jacket.<br>
                            Else if it's cool, wear a light jacket.<br>
                            Else if it's warm, wear a t-shirt.<br>
                            Else (if it's hot), wear shorts.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Write a program that takes a number representing a day of the week (1 for Monday, 2 for Tuesday, ..., 7 for Sunday). Print the name of the day. If the number is not between 1 and 7, print "Invalid day".</p>
                        </div>`
          },
          {
            id: "ternary-operator", title: "1.7 Ternary Operator",
            content: `
                        <p>A shorthand way to write a simple <code>if-else</code> statement in a single line. It's called "ternary" because it takes three operands (parts).</p>
                        <p><strong>Syntax:</strong> <code>condition ? expressionIfTrue : expressionIfFalse;</code></p>
                        <p><strong>Example:</strong></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  int age = 20;
  String message;

  // Using if-else
  if (age >= 18) {
    message = 'Adult';
  } else {
    message = 'Minor';
  }
  print('Using if-else: \$message');

  // Using ternary operator
  String ternaryMessage = (age >= 18) ? 'Adult' : 'Minor';
  print('Using ternary: \$ternaryMessage');

  // Can also be used directly in print or assignments
  print((age >= 18) ? 'You can vote.' : 'You cannot vote yet.');
}</code></pre>
                        </div>
                        <p><strong>Explanation:</strong> <code>(age >= 18)</code> is the condition. If it's true, the value is 'Adult'. If it's false, the value is 'Minor'.</p>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>You are at a counter. The cashier asks, "Cash or Card?". Your choice (condition) ? use cash machine (expressionIfTrue) : use card machine (expressionIfFalse).</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Using the ternary operator, write a program that checks if a variable <code>isRaining</code> (boolean) is true. If true, set a <code>whatToDo</code> string to "Take an umbrella", otherwise set it to "Enjoy the sunshine". Print <code>whatToDo</code>.</p>
                        </div>`
          },
          {
            id: "null-aware-operators", title: "1.8 Null-Aware Operators",
            content: `
                        <p>Dart has strong null safety, meaning variables cannot be null (have no value) unless you explicitly say they can. Null-aware operators help you work with variables that might be null, preventing errors.</p>
                        <p>A variable is "nullable" if you put a <code>?</code> after its type: <code>String? name; // name can be a String or null</code></p>
                        <h4>a. <code>??</code> (If null operator or Null Coalescing Operator):</h4>
                        <p>Provides a default value if an expression is null. <code>expression1 ?? expression2</code>. If <code>expression1</code> is not null, it uses <code>expression1</code>. Otherwise, it uses <code>expression2</code>.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  String? name; // name is null initially
  // name = 'Alice'; // Try uncommenting this line

  String displayName = name ?? 'Guest';
  print('Hello, \$displayName'); // If name is null, prints "Hello, Guest"
                                // If name is 'Alice', prints "Hello, Alice"
}</code></pre>
                        </div>
                        <h4>b. <code>?.</code> (Null-aware access or Conditional Member Access Operator):</h4>
                        <p>Calls a method or accesses a property on an object only if that object is not null. If the object is null, the expression evaluates to null and doesn't cause an error.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  String? text;
  // text = "Hello";

  int? length = text?.length;
  print('Length of text: \$length'); // If text is null, prints "Length of text: null"
                                   // If text is "Hello", prints "Length of text: 5"
}</code></pre>
                        </div>
                        <h4>c. <code>??=</code> (Null-aware assignment operator):</h4>
                        <p>Assigns a value to a variable only if that variable is currently null. <code>variable ??= value;</code></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  String? preferredColor; // preferredColor is null

  preferredColor ??= 'Blue'; // Assigns 'Blue' because preferredColor is null
  print('Preferred color: \$preferredColor'); // Output: Blue

  preferredColor ??= 'Red'; // Does nothing, preferredColor is already 'Blue' (not null)
  print('Preferred color: \$preferredColor'); // Output: Blue
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example (<code>??</code>):</h4>
                            <p>You ask for a specific brand of soda. If they have it (<code>name</code>), you get it. If not (<code>??</code>), you get a default soda ('Guest' or 'Any Cola').</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <ol class="list-decimal list-inside space-y-2">
                                <li>Declare a nullable integer <code>int? age;</code>.</li>
                                <li>Use the <code>??</code> operator to assign a default age of 18 to a new variable <code>displayAge</code> if <code>age</code> is null. Print <code>displayAge</code>.</li>
                                <li>Assign a value to <code>age</code> (e.g., <code>age = 25;</code>) and see how <code>displayAge</code> changes when you run the code again.</li>
                            </ol>
                        </div>`
          },
          {
            id: "switch-case", title: "1.9 switch-case Statement",
            content: `
                        <p>The <code>switch-case</code> statement is an alternative to a long <code>if-else if-else</code> ladder when you need to compare a single variable against several possible constant values.</p>
                        <p><strong>Syntax:</strong></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>switch (variable) {
  case value1:
    // Code to execute if variable == value1
    break; // Important: stops execution within the switch
  case value2:
    // Code to execute if variable == value2
    break;
  // ... more cases
  default:
    // Code to execute if variable doesn't match any case
}</code></pre>
                        </div>
                        <p><strong>Key points:</strong></p>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li>Each <code>case</code> must end with a <code>break</code> statement (or <code>return</code>, <code>throw</code>).</li>
                            <li>The <code>default</code> case is optional and executes if no other case matches.</li>
                            <li>You can only use <code>int</code>, <code>String</code>, or compile-time constants in <code>case</code> expressions.</li>
                        </ul>
                        <p><strong>Example:</strong></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  String command = 'open';

  switch (command) {
    case 'open':
      print('Opening the file...');
      break;
    case 'close':
      print('Closing the file...');
      break;
    default:
      print('Unknown command.');
  }
}</code></pre>
                        </div>
                        <div class="note"><p><strong>Fall-through:</strong> Dart has stricter rules about fall-through. A non-empty case clause must end with <code>break</code>, <code>return</code>, <code>throw</code>, or <code>continue</code> (if inside a loop). For intentional fall-through (rarely needed), you can have an empty case fall through to the next one.</p></div>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  String fruit = 'apple';
  switch (fruit) {
    case 'apple':
    case 'banana': // 'banana' will execute the same code as 'apple'
      print('It is a common fruit.');
      break;
    case 'orange':
      print('It is an orange.');
      break;
    default:
      print('Some other fruit.');
  }
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>A vending machine. You press a button (the variable).<br>
                            case 'A1': Dispense Coke. break;<br>
                            case 'A2': Dispense Pepsi. break;<br>
                            default: Invalid selection.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Write a program that takes a String variable <code>grade</code> ('A', 'B', 'C', 'D', 'F'). Use a <code>switch</code> statement to print a message like:<br>
                            ● 'A': "Excellent!"<br>
                            ● 'B': "Good job!"<br>
                            ● 'C': "Satisfactory."<br>
                            ● 'D': "Needs improvement."<br>
                            ● 'F': "Failed."<br>
                            ● For any other grade: "Invalid grade."</p>
                        </div>`
          },
          {
            id: "for-loop", title: "1.10 for Loop",
            content: `
                        <p>A <code>for</code> loop is used to repeat a block of code a specific number of times.</p>
                        <p><strong>Syntax:</strong> <code>for (initializer; condition; increment/decrement) { /* Code to repeat */ }</code></p>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>initializer</code>: Executed once before the loop starts (e.g., <code>int i = 0;</code>).</li>
                            <li><code>condition</code>: Checked before each iteration. If true, the loop continues. If false, the loop stops.</li>
                            <li><code>increment/decrement</code>: Executed after each iteration (e.g., <code>i++</code>).</li>
                        </ul>
                        <p><strong>Example:</strong></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  // Print numbers from 1 to 5
  for (int i = 1; i <= 5; i++) {
    print('Number: \$i');
  }

  // Countdown from 3 to 1
  for (int j = 3; j >= 1; j--) {
    print('Countdown: \$j');
  }
  print('Blast off!');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>You have 5 tasks on your to-do list.<br>
                            for each task from 1 to 5:<br>
                            &nbsp;&nbsp;Do the task.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <ol class="list-decimal list-inside space-y-2">
                                <li>Write a <code>for</code> loop that prints all even numbers from 2 to 10 (inclusive).</li>
                                <li>Write a <code>for</code> loop that calculates the sum of numbers from 1 to 10. Print the final sum.</li>
                            </ol>
                        </div>`
          },
          {
            id: "for-in-loop", title: "1.11 for-in Loop",
            content: `
                        <p>Used to iterate over the elements of a collection (like a List or Set) or other iterable objects.</p>
                        <p><strong>Syntax:</strong> <code>for (var item in collection) { /* Code to execute for each item */ }</code></p>
                        <p><strong>Example (using a List):</strong></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  List<String> fruits = ['Apple', 'Banana', 'Orange'];
  for (String fruit in fruits) {
    print('I like \$fruit');
  }

  List<int> numbers = [1, 2, 3, 4, 5];
  int sum = 0;
  for (int number in numbers) {
    sum = sum + number;
  }
  print('Sum of numbers: \$sum');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>You have a basket of fruits (collection).<br>
                            for each fruit in the basket:<br>
                            &nbsp;&nbsp;Take out the fruit and examine it.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Imagine you have a list of your favorite hobbies (create a <code>List&lt;String&gt; hobbies = ['Reading', 'Gaming', 'Coding'];</code>). Use a <code>for-in</code> loop to print "I enjoy [hobby name]" for each hobby.</p>
                        </div>`
          },
          {
            id: "while-loop", title: "1.12 while Loop",
            content: `
                        <p>A <code>while</code> loop repeats a block of code as long as a specified condition is true. The condition is checked before each iteration.</p>
                        <p><strong>Syntax:</strong> <code>while (condition) { /* Code to repeat */ }</code></p>
                        <div class="note"><p>Make sure to change something that affects the condition inside the loop, otherwise you might create an infinite loop!</p></div>
                        <p><strong>Example:</strong></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  int count = 1;
  while (count <= 5) {
    print('While loop count: \$count');
    count++; // Very important!
  }

  int batteryLevel = 100;
  while (batteryLevel > 0) {
    print('Battery: \$batteryLevel%');
    batteryLevel = batteryLevel - 10;
    if (batteryLevel == 20) {
        print('Low battery warning!');
    }
  }
  print('Battery empty!');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>You are stirring a pot of soup while it is not boiling. Once it boils (condition becomes false), you stop stirring.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Write a <code>while</code> loop that starts with a variable <code>number = 10</code> and prints the number, then divides it by 2 in each step, as long as the number is greater than or equal to 1.</p>
                        </div>`
          },
          {
            id: "do-while-loop", title: "1.13 do-while Loop",
            content: `
                        <p>Similar to a <code>while</code> loop, but the <code>do-while</code> loop executes the code block at least once before checking the condition. The condition is checked after each iteration.</p>
                        <p><strong>Syntax:</strong> <code>do { /* Code to repeat */ } while (condition);</code></p>
                        <p><strong>Example:</strong></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  int i = 1;
  do {
    print('Do-while loop i: \$i');
    i++;
  } while (i <= 5);

  // Example showing it runs at least once
  int j = 6;
  do {
    print('Do-while loop j (runs once): \$j'); // This will print
    j++;
  } while (j <= 5); // Condition 6 <= 5 is false, but block already ran.
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>You enter a password at least once (<code>do</code> block). <code>while</code> the password is incorrect (condition), you are asked to enter it again.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Write a <code>do-while</code> loop that asks the user for a number (you can simulate this by setting a variable). The loop should continue as long as the number entered is not 0. Print the number in each iteration. (For now, just use a variable and change it inside the loop to eventually become 0).</p>
                        </div>`
          },
          {
            id: "break-statement", title: "1.14 break Statement",
            content: `
                        <p>The <code>break</code> statement is used to immediately exit a loop (<code>for</code>, <code>while</code>, <code>do-while</code>) or a <code>switch</code> statement, regardless of the loop's condition.</p>
                        <p><strong>Example (in a <code>for</code> loop):</strong></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  for (int i = 1; i <= 10; i++) {
    if (i == 5) {
      print('Found 5, breaking the loop!');
      break; // Exit the loop immediately
    }
    print('Current number: \$i');
  }
  print('Loop finished.');
}
// Output:
// Current number: 1
// Current number: 2
// Current number: 3
// Current number: 4
// Found 5, breaking the loop!
// Loop finished.</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>You are searching for a specific book in a pile of 10 books. You go through them one by one (<code>for</code> loop). If you find the book (<code>i == 5</code>), you stop searching (<code>break</code>).</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Write a <code>while</code> loop that counts from 1 up. Inside the loop, if the count reaches 7, print "Reached 7, stopping!" and <code>break</code> the loop. Also, print the count in each iteration before the check.</p>
                        </div>`
          },
          {
            id: "continue-statement", title: "1.15 continue Statement",
            content: `
                        <p>The <code>continue</code> statement skips the current iteration of a loop and immediately proceeds to the next iteration.</p>
                        <p><strong>Example (in a <code>for</code> loop):</strong></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  for (int i = 1; i <= 5; i++) {
    if (i == 3) {
      print('Skipping number 3.');
      continue; // Skip the rest of this iteration
    }
    print('Processing number: \$i');
  }
  print('Loop finished.');
}
// Output:
// Processing number: 1
// Processing number: 2
// Skipping number 3.
// Processing number: 4
// Processing number: 5
// Loop finished.</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>You are checking a list of items to pack for a trip. For each item: If the item is "heavy stone" (condition), you <code>continue</code> (skip packing it) and move to the next item. Otherwise, you pack the item.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Write a <code>for</code> loop that iterates from 1 to 10. If a number is odd, use <code>continue</code> to skip printing it. If it's even, print "Even number: [number]".</p>
                        </div>`
          },
          {
            id: "module1-practice", title: "Module 1: Practice Questions Review",
            isPractice: true,
            content: `
                        <p>Phew! That was a lot for Module 1. These concepts of conditions and loops are fundamental to programming. Practice them well!</p>
                        <ol class="list-decimal list-inside space-y-2 mt-4">
                            <li><strong>Grade Calculator:</strong> Based on <code>marks</code> (0-100), print "A" (90-100), "B" (80-89), "C" (70-79), "D" (60-69), "F" (<60) using <code>if-else if-else</code>.</li>
                            <li><strong>Vowel/Consonant Checker:</strong> Take a character. Use a <code>switch</code> statement to check if it's a vowel (a, e, i, o, u) or a consonant. Handle uppercase/lowercase.</li>
                            <li><strong>Multiplication Table:</strong> Print the multiplication table for 5 (from 5x1 to 5x10) using a <code>for</code> loop.</li>
                            <li><strong>Guess the Number (Simple):</strong> Set a <code>secretNumber</code>. Use a <code>while</code> loop to "ask" for a guess (simulate by decrementing a <code>triesLeft</code> variable). If guess matches, print "Correct!" and <code>break</code>. If <code>triesLeft</code> is 0, print "Out of tries."</li>
                            <li><strong>Sum of Numbers (Skipping Multiples of 3):</strong> Calculate the sum of numbers from 1 to 15. If a number is a multiple of 3, use <code>continue</code> to skip adding it to the sum. Print the final sum.</li>
                        </ol>`
          }
        ]
      },
      module2: { // Corresponds to PDF Module 2
        title: "Module 2: Collections (Lists & Introduction to Sets)",
        introduction: "Collections are used to store groups of related data. This module focuses on Dart's <code>List</code> collection in detail and introduces <code>Set</code>s. We'll cover creating, accessing, modifying, and iterating through lists, as well as basic Set operations. Maps will be covered in a later module. This content is from Module 2 of the PDF.",
        sections: [
          {
            id: "collections-use-cases", title: "2.1 Collection's Practical Use Cases",
            content: `
                        <h4>Why do we need collections?</h4>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><strong>Shopping List:</strong> A list of items you want to buy (e.g., <code>['Milk', 'Eggs', 'Bread']</code>).</li>
                            <li><strong>Student Roster:</strong> A list of students in a class.</li>
                            <li><strong>Phone Contacts:</strong> Each contact has a name (key) and a phone number (value) – this is good for a Map (covered later).</li>
                            <li><strong>Unique Tags:</strong> A set of unique tags for a blog post (e.g., <code>{'dart', 'programming', 'flutter'}</code>). Duplicates are not allowed.</li>
                            <li><strong>Storing User Preferences:</strong> Key-value pairs like <code>'theme': 'dark', 'fontSize': 14</code> (Map).</li>
                        </ul>
                        <p>Collections help organize, manage, and manipulate groups of data efficiently.</p>`
          },
          {
            id: "collections-types", title: "2.2 Types of Collections in Dart",
            content: `
                        <p>Dart has three main types of collections:</p>
                        <ol class="list-decimal list-inside my-2 ml-4">
                            <li><strong>List:</strong> An ordered collection of items. Items can be accessed by their index (position). Duplicates are allowed.
                                <ul class="list-disc list-inside my-2 ml-4">
                                    <li>Example: <code>[1, 2, 2, 3, 4]</code></li>
                                    <li>Think of it like a numbered list of songs in a playlist.</li>
                                </ul>
                            </li>
                            <li><strong>Set:</strong> An unordered collection of unique items. Duplicates are automatically removed.
                                <ul class="list-disc list-inside my-2 ml-4">
                                    <li>Example: <code>{1, 2, 3, 4}</code> (if you try to add 2 again, it won't change)</li>
                                    <li>Think of it like a group of unique ingredients for a recipe.</li>
                                </ul>
                            </li>
                            <li><strong>Map:</strong> A collection of key-value pairs. Each key must be unique. Values can be accessed using their corresponding key. (Covered in detail later)
                                <ul class="list-disc list-inside my-2 ml-4">
                                    <li>Example: <code>{'name': 'Alice', 'age': 30}</code></li>
                                    <li>Think of it like a dictionary where each word (key) has a definition (value).</li>
                                </ul>
                            </li>
                        </ol>`
          },
          {
            id: "lists-creating", title: "2.3 Creating Mutable and Immutable Lists",
            content: `
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><strong>Mutable List:</strong> A list whose contents (items, size) can be changed after it's created. This is the default type of list.</li>
                            <li><strong>Immutable List:</strong> A list whose contents cannot be changed once it's created. You often create these using the <code>const</code> keyword if the values are known at compile time, or by using methods that return unmodifiable views.</li>
                        </ul>
                        <h4>Creating Mutable Lists:</h4>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  // Using literal syntax (most common)
  List<String> fruits = ['Apple', 'Banana', 'Mango'];
  List<int> numbers = [1, 2, 3, 4, 5];
  List<dynamic> mixedList = [1, 'Hello', true, 3.14]; // Can hold different types

  // Using the List constructor (less common for simple lists)
  var emptyList = List<String>.empty(growable: true); // Creates an empty, growable list
  var filledList = List<int>.filled(5, 0, growable: true); // [0, 0, 0, 0, 0]

  print('Fruits: \$fruits');
  print('Numbers: \$numbers');
  print('Mixed List: \$mixedList');
  print('Empty List: \$emptyList');
  print('Filled List: \$filledList');

  fruits.add('Orange'); // Modifying a mutable list
  print('Fruits after adding Orange: \$fruits');
}</code></pre>
                        </div>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>List&lt;String&gt;</code>: Specifies that the list will hold String values. This is called using generics.</li>
                            <li><code>growable: true</code>: Allows the list to change size (add/remove items).</li>
                        </ul>
                        <h4>Creating Immutable Lists (Compile-time constant):</h4>
                        <p>If the list's contents are known when you write the code, you can make it <code>const</code>.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  const List<String> constantFruits = ['Apple', 'Banana'];
  // constantFruits.add('Orange'); // ERROR: Cannot add to an unmodifiable list
  // constantFruits[0] = 'Pear';   // ERROR: Cannot modify an unmodifiable list
  print('Constant Fruits: \$constantFruits');

  // Another way for runtime immutability (unmodifiable view)
  List<int> numbers = [1, 2, 3];
  List<int> unmodifiableNumbers = List.unmodifiable(numbers);
  // unmodifiableNumbers.add(4); // ERROR at runtime
  print('Unmodifiable Numbers: \$unmodifiableNumbers');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <ul class="list-disc list-inside my-2 ml-4">
                                <li><strong>Mutable List:</strong> Your grocery shopping list on a piece of paper. You can add or cross off items.</li>
                                <li><strong>Immutable List:</strong> The list of ingredients printed on a packaged food item. It doesn't change.</li>
                            </ul>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <ol class="list-decimal list-inside space-y-2">
                                <li>Create a mutable list of your three favorite movies (as Strings). Print the list.</li>
                                <li>Create a <code>const</code> list of the first three prime numbers (2, 3, 5). Try to add another number to it and observe the error.</li>
                            </ol>
                        </div>`
          },
          {
            id: "lists-accessing", title: "2.4 Accessing List Items",
            content: `
                        <p>You access items in a list using their index. Indices start from 0 for the first item.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  List<String> colors = ['Red', 'Green', 'Blue'];

  // Accessing items by index
  String firstColor = colors[0];  // Index 0 is 'Red'
  String secondColor = colors[1]; // Index 1 is 'Green'
  // String fourthColor = colors[3]; // ERROR: RangeError (index out of bounds)

  print('First color: \$firstColor');
  print('Second color: \$secondColor');

  // Getting the length of the list
  print('Number of colors: \${colors.length}'); // Output: 3

  // Accessing the last item
  String lastColor = colors[colors.length - 1];
  // Or using a handy property (safer if list might be empty)
  String? lastColorProp = colors.isNotEmpty ? colors.last : null;

  print('Last color (manual): \$lastColor');
  print('Last color (property): \$lastColorProp');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Think of a list of apartments in a building. Each apartment has a number (index). "Apartment 0" is the first one.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Create a list of your top 3 favorite songs. Print the second song in the list.</p>
                        </div>`
          },
          {
            id: "lists-adding", title: "2.5 Adding Items to a List",
            content: `
                        <p>You can add items to a mutable list using several methods:</p>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>add(value)</code>: Adds an item to the end of the list.</li>
                            <li><code>addAll(collection)</code>: Adds all items from another collection to the end of the list.</li>
                            <li><code>insert(index, value)</code>: Inserts an item at a specific index, shifting subsequent items.</li>
                            <li><code>insertAll(index, collection)</code>: Inserts all items from another collection at a specific index.</li>
                        </ul>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  List<String> tasks = ['Wake up', 'Brush teeth'];
  print('Initial tasks: \$tasks');

  // add()
  tasks.add('Eat breakfast');
  print('After add: \$tasks');

  // addAll()
  List<String> afternoonTasks = ['Work', 'Lunch'];
  tasks.addAll(afternoonTasks);
  print('After addAll: \$tasks');

  // insert()
  tasks.insert(1, 'Exercise'); // Insert 'Exercise' at index 1
  print('After insert: \$tasks');

  // insertAll()
  List<String> eveningTasks = ['Read book', 'Sleep'];
  tasks.insertAll(tasks.length - 1, eveningTasks); // Insert before the last element
  print('After insertAll: \$tasks');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Adding a new task to your to-do list. If it's urgent, you might insert it near the top.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <ol class="list-decimal list-inside space-y-2">
                                <li>Create an empty list of strings called <code>shoppingList</code>.</li>
                                <li>Add "Milk", "Bread", and "Eggs" to it one by one using <code>add()</code>.</li>
                                <li>Then, add a list containing "Butter" and "Cheese" using <code>addAll()</code>.</li>
                                <li>Insert "Apples" at the beginning of the list. Print the final <code>shoppingList</code>.</li>
                            </ol>
                        </div>`
          },
          {
            id: "lists-removing", title: "2.6 Removing Items from a List",
            content: `
                        <p>You can remove items from a mutable list:</p>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>remove(value)</code>: Removes the first occurrence of the specified value. Returns <code>true</code> if successful.</li>
                            <li><code>removeAt(index)</code>: Removes the item at the specified index. Returns the removed item.</li>
                            <li><code>removeLast()</code>: Removes and returns the last item.</li>
                            <li><code>removeWhere(test)</code>: Removes all items that satisfy the given test (a function).</li>
                            <li><code>clear()</code>: Removes all items from the list.</li>
                        </ul>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  List<String> items = ['Pen', 'Pencil', 'Eraser', 'Book', 'Pencil'];
  print('Initial items: \$items');

  // remove()
  bool removed = items.remove('Pencil'); // Removes the first 'Pencil'
  print('After remove("Pencil"): \$items, Removed: \$removed');

  // removeAt()
  String removedItem = items.removeAt(2); // Removes 'Book' (at new index 2)
  print('After removeAt(2): \$items, Removed Item: \$removedItem');

  // removeLast()
  String lastItem = items.removeLast(); // Removes the last 'Pencil'
  print('After removeLast(): \$items, Last Item Removed: \$lastItem');

  // removeWhere()
  List<int> numbers = [1, 2, 3, 4, 5, 6];
  numbers.removeWhere((number) => number % 2 == 0); // Remove all even numbers
  print('After removeWhere (even numbers): \$numbers');

  // clear()
  items.clear();
  print('After clear(): \$items, Is empty: \${items.isEmpty}');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Removing a completed task from your to-do list. Or removing an item you decided not to buy from your shopping cart.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <ol class="list-decimal list-inside space-y-2">
                                <li>Create a list <code>[10, 20, 30, 40, 50, 30]</code>.</li>
                                <li>Remove the first occurrence of 30.</li>
                                <li>Remove the item at index 2.</li>
                                <li>Remove all numbers greater than 25 using <code>removeWhere()</code>. Print the list after each step.</li>
                            </ol>
                        </div>`
          },
          {
            id: "lists-updating", title: "2.7 Updating List Items",
            content: `
                        <p>You can change an item at a specific index by assigning a new value to it.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  List<String> plan = ['Go to Gym', 'Meeting at 10 AM', 'Lunch with Client'];
  print('Original plan: \$plan');

  // Update the item at index 1
  if (plan.length > 1) { // Good practice to check bounds
    plan[1] = 'Team Meeting at 11 AM';
  }
  print('Updated plan: \$plan');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Your calendar has "Doctor's Appointment" at 3 PM. The doctor reschedules to 4 PM, so you update that entry.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Create a list of strings: <code>['Learn Dart', 'Build App', 'Publish App']</code>. Change the second item to "Build Awesome App". Print the updated list.</p>
                        </div>`
          },
          {
            id: "lists-looping", title: "2.8 Looping Through a List",
            content: `
                        <p>You can iterate over the items in a list using loops:</p>
                        <h4><code>for-in</code> loop (preferred for simplicity):</h4>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  List<String> names = ['Alice', 'Bob', 'Charlie'];
  for (String name in names) {
    print('Hello, \$name!');
  }
}</code></pre>
                        </div>
                        <h4><code>forEach</code> method (functional style):</h4>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  List<String> names = ['Alice', 'Bob', 'Charlie'];
  names.forEach((name) {
    print('Greetings, \$name!');
  });
  // Shorter version using arrow function:
  // names.forEach((name) => print('Greetings, \$name!'));
}</code></pre>
                        </div>
                        <h4>Traditional <code>for</code> loop (if you need the index):</h4>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  List<String> names = ['Alice', 'Bob', 'Charlie'];
  for (int i = 0; i < names.length; i++) {
    print('Name at index \$i is \${names[i]}');
  }
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Going through each item on your checklist and marking it as done.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Create a list of numbers <code>[1, 2, 3, 4, 5]</code>. Use a <code>for-in</code> loop to print the square of each number (<code>number * number</code>).</p>
                        </div>`
          },
          {
            id: "lists-sorting-reversing", title: "2.9 Sorting and Reversing a List",
            content: `
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>sort()</code>: Sorts the list in place (modifies the original list). By default, it sorts in ascending order. For custom sorting, you can provide a comparison function.</li>
                            <li><code>List.reversed</code>: Returns an iterable that provides the items in reverse order. To get a new list, use <code>.toList()</code>.</li>
                        </ul>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  List<int> numbers = [3, 1, 4, 1, 5, 9, 2, 6];
  print('Original numbers: \$numbers');

  numbers.sort(); // Sorts in ascending order
  print('Sorted numbers: \$numbers');

  List<String> words = ['banana', 'Apple', 'cherry', 'Date'];
  words.sort(); // Sorts alphabetically, case-sensitive ('Apple' before 'banana')
  print('Sorted words (case-sensitive): \$words');

  // Case-insensitive sort
  words.sort((a, b) => a.toLowerCase().compareTo(b.toLowerCase()));
  print('Sorted words (case-insensitive): \$words');

  // Sorting in descending order
  numbers.sort((a, b) => b.compareTo(a)); // b comes before a for descending
  print('Descending sorted numbers: \$numbers');

  // Reversing a list
  List<int> originalOrder = [1, 2, 3, 4, 5];
  List<int> reversedOrder = originalOrder.reversed.toList();
  print('Original order: \$originalOrder');
  print('Reversed order: \$reversedOrder');
  // Note: originalOrder.reversed is an Iterable, not a List.
  // originalOrder itself is not changed by .reversed
}</code></pre>
                        </div>
                        <p><code>compareTo()</code>: This method is used by <code>sort()</code>. <code>a.compareTo(b)</code> returns:</p>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li>&lt; 0 if <code>a</code> comes before <code>b</code></li>
                            <li>0 if <code>a</code> and <code>b</code> are equal</li>
                            <li>&gt; 0 if <code>a</code> comes after <code>b</code></li>
                        </ul>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Sorting a list of student names alphabetically. Or sorting exam scores from highest to lowest.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <ol class="list-decimal list-inside space-y-2">
                                <li>Create a list of strings: <code>['Zebra', 'apple', 'Banana', 'cat']</code>.</li>
                                <li>Sort it in default (case-sensitive) order and print it.</li>
                                <li>Sort it in case-insensitive alphabetical order and print it.</li>
                                <li>Sort it by the length of the strings (shortest to longest) and print it. (Hint: <code>(a, b) => a.length.compareTo(b.length)</code>)</li>
                            </ol>
                        </div>`
          },
          {
            id: "sets-creating", title: "2.10 Creating a Set",
            content: `
                        <p>A Set is an unordered collection of unique items.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  // Using literal syntax
  Set<String> uniqueFruits = {'Apple', 'Banana', 'Mango', 'Apple'}; // 'Apple' only appears once
  print('Unique fruits: \$uniqueFruits'); // Order might not be guaranteed

  // Creating an empty set
  // Set<int> emptySet = {}; // THIS CREATES AN EMPTY MAP BY DEFAULT!
  Set<int> correctEmptySet = <int>{}; // Use type annotation for an empty Set
  var anotherEmptySet = Set<int>();   // Or use the constructor

  // print('Incorrect empty set (is Map): \${emptySet.runtimeType}');
  print('Correct empty set: \$correctEmptySet, Type: \${correctEmptySet.runtimeType}');
  print('Another empty set: \$anotherEmptySet, Type: \${anotherEmptySet.runtimeType}');

  // Creating a set from a list (removes duplicates)
  List<int> numbersWithDuplicates = [1, 2, 2, 3, 4, 4, 5];
  Set<int> uniqueNumbers = Set.from(numbersWithDuplicates);
  print('Numbers with duplicates: \$numbersWithDuplicates');
  print('Unique numbers from list: \$uniqueNumbers');
}</code></pre>
                        </div>
                        <div class="note"><p><strong>Important:</strong> <code>var mySet = {};</code> creates an empty Map, not an empty Set. To create an empty Set, use <code>var mySet = &lt;Type&gt;{};</code> or <code>Set&lt;Type&gt; mySet = {};</code> or <code>var mySet = Set&lt;Type&gt;();</code>.</p></div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>A collection of unique stamps. If you get a duplicate stamp, you still only have one of that kind in your unique collection.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <ol class="list-decimal list-inside space-y-2">
                                <li>Create a Set of integers containing 10, 20, 30, 20, 40. Print the set to see that 20 appears only once.</li>
                                <li>Create an empty Set to store student IDs (integers).</li>
                            </ol>
                        </div>`
          },
          {
            id: "sets-adding", title: "2.11 Adding Items to a Set",
            content: `
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>add(value)</code>: Adds an item. If the item is already present, the set does not change. Returns <code>true</code> if the value was added (was not already in the set), <code>false</code> otherwise.</li>
                            <li><code>addAll(collection)</code>: Adds all items from another collection. Duplicates are ignored.</li>
                        </ul>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  Set<String> colors = {'Red', 'Green'};
  print('Initial colors: \$colors');

  // add()
  bool addedBlue = colors.add('Blue');
  print('After adding Blue: \$colors, Was Blue added? \$addedBlue');

  bool addedRedAgain = colors.add('Red'); // 'Red' is already there
  print('After adding Red again: \$colors, Was Red added again? \$addedRedAgain');

  // addAll()
  List<String> moreColors = ['Yellow', 'Green', 'Purple'];
  colors.addAll(moreColors); // 'Green' is a duplicate, will be ignored
  print('After addAll: \$colors');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Adding a new, unique book to your bookshelf. If you already have that exact book, you don't add another copy to your unique collection.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <ol class="list-decimal list-inside space-y-2">
                                <li>Create an empty set of strings called <code>guestList</code>.</li>
                                <li>Add "Alice", "Bob", and "Charlie" to it.</li>
                                <li>Try adding "Alice" again.</li>
                                <li>Print the <code>guestList</code>.</li>
                            </ol>
                        </div>`
          },
          {
            id: "module2-practice", title: "Module 2: Practice Questions (Lists & Intro to Sets)",
            isPractice: true,
            content: `
                        <p>This concludes "Dart Collections (Part 1)". Next up is "Dart Collections (Part 2)" focusing on more Set operations and Maps.</p>
                        <ol class="list-decimal list-inside space-y-2 mt-4">
                            <li><strong>List Operations:</strong> Create a list of integers <code>[5, 2, 8, 1, 9, 4]</code>.
                                <ul class="list-disc list-inside ml-4">
                                    <li>Print the element at index 3.</li>
                                    <li>Add the number 7 to the end.</li>
                                    <li>Insert the number 0 at the beginning.</li>
                                    <li>Remove the number 8.</li>
                                    <li>Sort the list in ascending order.</li>
                                    <li>Print the final list.</li>
                                </ul>
                            </li>
                            <li><strong>Set Uniqueness:</strong> Create a list of strings with some duplicates: <code>['apple', 'banana', 'orange', 'apple', 'grape', 'banana']</code>.
                                <ul class="list-disc list-inside ml-4">
                                    <li>Create a Set from this list. Print the set to show only unique items.</li>
                                    <li>Add "kiwi" to the set.</li>
                                    <li>Try adding "apple" again to the set. Print the set.</li>
                                </ul>
                            </li>
                            <li><strong>List Manipulation:</strong> Given <code>List<String> words = ["Dart", "is", "fun", "to", "learn"];</code>
                                <ul class="list-disc list-inside ml-4">
                                    <li>Create a new list containing only words with length greater than 3.</li>
                                    <li>Create a new list where each word is reversed.</li>
                                </ul>
                            </li>
                        </ol>`
          }
        ]
      },
      module3: { // Corresponds to PDF Module 3
        title: "Module 3: Collections (More on Sets, and Maps)",
        introduction: "Let's continue with Sets, covering removal, existence checks, operations, and conversion. Then we'll dive into Maps: creating them, accessing items, adding, updating, removing, and looping. This content is from Module 3 of the PDF.",
        sections: [
          {
            id: "sets-removing", title: "3.1 Removing Items from a Set",
            content: `
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>remove(value)</code>: Removes the specified value from the set. Returns <code>true</code> if the value was in the set and was removed, <code>false</code> otherwise.</li>
                            <li><code>removeAll(collection)</code>: Removes all elements of the given collection from this set.</li>
                            <li><code>removeWhere(test)</code>: Removes all elements that satisfy <code>test</code>.</li>
                            <li><code>clear()</code>: Removes all elements from the set.</li>
                        </ul>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  Set<String> ingredients = {'flour', 'sugar', 'eggs', 'butter'};
  print('Initial ingredients: \$ingredients');

  // remove()
  bool removedSugar = ingredients.remove('sugar');
  print('After removing sugar: \$ingredients, Was sugar removed? \$removedSugar');

  bool removedSalt = ingredients.remove('salt'); // 'salt' is not in the set
  print('After trying to remove salt: \$ingredients, Was salt removed? \$removedSalt');

  // removeWhere()
  ingredients.add('baking soda');
  ingredients.removeWhere((item) => item.startsWith('b'));
  print('After removing items starting with "b": \$ingredients');

  // clear()
  ingredients.clear();
  print('After clear: \$ingredients, Is empty: \${ingredients.isEmpty}');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>You have a set of unique invitation cards. If someone can't come, you remove their card from the set to be sent.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <ol class="list-decimal list-inside space-y-2">
                                <li>Create a Set <code>mySet</code> with integers 1, 2, 3, 4, 5.</li>
                                <li>Remove the number 3.</li>
                                <li>Try to remove the number 10.</li>
                                <li>Remove all odd numbers using <code>removeWhere()</code>.</li>
                                <li>Print the set after each step.</li>
                            </ol>
                        </div>`
          },
          {
            id: "sets-existence", title: "3.2 Checking for an Item's Existence in a Set",
            content: `
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>contains(value)</code>: Returns <code>true</code> if the set contains the specified value.</li>
                            <li><code>containsAll(collection)</code>: Returns <code>true</code> if the set contains all elements of the given collection.</li>
                        </ul>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  Set<String> allowedUsers = {'admin', 'editor', 'viewer'};

  print('Does set contain "editor"? \${allowedUsers.contains('editor')}');   // true
  print('Does set contain "guest"? \${allowedUsers.contains('guest')}');     // false

  List<String> checkUsers = ['admin', 'viewer'];
  print('Does set contain all of checkUsers? \${allowedUsers.containsAll(checkUsers)}'); // true

  List<String> checkUsers2 = ['admin', 'unknown'];
  print('Does set contain all of checkUsers2? \${allowedUsers.containsAll(checkUsers2)}'); // false
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Checking if a specific guest's name is on your unique guest list (<code>contains</code>).</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Create a Set of your favorite fruits. Then, check if "Apple" is in your set and print the result. Check if "Grape" is in your set and print the result.</p>
                        </div>`
          },
          {
            id: "sets-operations", title: "3.3 Set Operations (Union, Intersection, Difference)",
            content: `
                        <p>Sets are great for mathematical set operations:</p>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>union(otherSet)</code>: Returns a new set containing all unique elements from both sets.</li>
                            <li><code>intersection(otherSet)</code>: Returns a new set containing only the elements that are common to both sets.</li>
                            <li><code>difference(otherSet)</code>: Returns a new set containing elements that are in the first set but not in the second set.</li>
                        </ul>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  Set<int> setA = {1, 2, 3, 4};
  Set<int> setB = {3, 4, 5, 6};

  // Union: All unique items from A and B
  Set<int> unionSet = setA.union(setB);
  print('Union (A U B): \$unionSet'); // Output: {1, 2, 3, 4, 5, 6}

  // Intersection: Common items in A and B
  Set<int> intersectionSet = setA.intersection(setB);
  print('Intersection (A ∩ B): \$intersectionSet'); // Output: {3, 4}

  // Difference: Items in A but not in B
  Set<int> differenceSetAB = setA.difference(setB);
  print('Difference (A - B): \$differenceSetAB'); // Output: {1, 2}

  // Difference: Items in B but not in A
  Set<int> differenceSetBA = setB.difference(setA);
  print('Difference (B - A): \$differenceSetBA'); // Output: {5, 6}
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <ul class="list-disc list-inside my-2 ml-4">
                                <li><strong>Union:</strong> List of all unique students who play either Football OR Basketball.</li>
                                <li><strong>Intersection:</strong> List of students who play BOTH Football AND Basketball.</li>
                                <li><strong>Difference:</strong> List of students who play Football BUT NOT Basketball.</li>
                            </ul>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <ol class="list-decimal list-inside space-y-2">
                                <li>Create <code>set1 = { 'a', 'b', 'c', 'd' }</code> and <code>set2 = { 'c', 'd', 'e', 'f' }</code>.</li>
                                <li>Find and print their union, intersection, and the difference <code>set1 - set2</code>.</li>
                            </ol>
                        </div>`
          },
          {
            id: "sets-to-list", title: "3.4 Converting Set to List",
            content: `
                        <p>You can easily convert a Set to a List using <code>toList()</code>. The order of elements in the resulting list might not be predictable as Sets are unordered (though often iteration order is based on insertion order for some Set implementations).</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  Set<String> uniqueNames = {'Eve', 'Adam', 'Seth'};
  print('Original Set: \$uniqueNames');

  List<String> nameList = uniqueNames.toList();
  print('Converted List: \$nameList');

  // You can sort the list if needed
  nameList.sort();
  print('Sorted List: \$nameList');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>You have a set of unique attendees for an event. You want to print them as a numbered list for check-in, so you convert the set to a list.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Create a Set of integers <code>{50, 10, 30, 20, 40}</code>. Convert it to a List and then sort the list. Print the sorted list.</p>
                        </div>`
          },
          {
            id: "maps-creating", title: "3.5 Creating a Map",
            content: `
                        <p>A Map stores data as key-value pairs. Keys must be unique.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  // Using literal syntax (most common)
  Map<String, String> capitals = {
    'USA': 'Washington D.C.',
    'India': 'New Delhi',
    'Japan': 'Tokyo'
  };
  print('Capitals: \$capitals');

  Map<int, String> studentNames = {
    101: 'Alice',
    102: 'Bob',
    103: 'Charlie'
  };
  print('Student Names: \$studentNames');

  // Creating an empty Map
  Map<String, int> emptyMap = {}; // This is an empty Map
  var anotherEmptyMap = Map<String, int>();
  print('Empty Map: \$emptyMap, Type: \${emptyMap.runtimeType}');
  print('Another Empty Map: \$anotherEmptyMap, Type: \${anotherEmptyMap.runtimeType}');
}</code></pre>
                        </div>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>Map&lt;String, int&gt;</code>: Specifies the type of keys (String) and values (int).</li>
                        </ul>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>A phone book: Name (key) -> Phone Number (value).<br>A dictionary: Word (key) -> Definition (value).</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <ol class="list-decimal list-inside space-y-2">
                                <li>Create a Map where keys are your friends' names (String) and values are their favorite colors (String).</li>
                                <li>Print the Map.</li>
                            </ol>
                        </div>`
          },
          {
            id: "maps-accessing", title: "3.6 Accessing Items from a Map",
            content: `
                        <p>You access values in a Map using their corresponding keys. If you try to access a key that doesn't exist, it returns <code>null</code>.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  Map<String, String> userProfile = {
    'name': 'John Doe',
    'email': 'john.doe@example.com',
    'city': 'New York'
  };

  String? name = userProfile['name']; // Access using the key 'name'
  String? country = userProfile['country']; // Key 'country' does not exist, so it returns null

  print('Name: \$name');
  print('Email: \${userProfile['email']}');
  print('Country: \$country'); // Output: null

  // Check if a key exists
  print('Does profile contain "city"? \${userProfile.containsKey('city')}');     // true
  print('Does profile contain "age"? \${userProfile.containsKey('age')}');       // false

  // Check if a value exists
  print('Does profile contain value "New York"? \${userProfile.containsValue('New York')}'); // true

  // Get the number of key-value pairs
  print('Number of entries: \${userProfile.length}');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Looking up a word in a dictionary. You use the word (key) to find its definition (value).</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Using the Map of friends and their favorite colors you created:</p>
                            <ol class="list-decimal list-inside space-y-2">
                                <li>Access and print Alice's favorite color (assuming Alice is a key).</li>
                                <li>Try to access and print David's favorite color (assuming David is not a key). Observe the <code>null</code> output.</li>
                            </ol>
                        </div>`
          },
          {
            id: "maps-adding-key-value", title: "3.7 Adding Key-Value Pairs to a Map",
            content: `
                        <p>You can add new key-value pairs or update existing ones:</p>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li>Using <code>[] =</code>:
                                <ul class="list-disc list-inside my-2 ml-4">
                                    <li>If the key doesn't exist, it adds the new key-value pair.</li>
                                    <li>If the key already exists, it updates the value for that key.</li>
                                </ul>
                            </li>
                            <li><code>putIfAbsent(key, () => value)</code>: Adds the key-value pair only if the key is not already present. It returns the new value or the existing value if the key was already there.</li>
                            <li><code>addAll(otherMap)</code>: Adds all key-value pairs from another map. If keys overlap, values from <code>otherMap</code> will overwrite existing ones.</li>
                        </ul>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  Map<String, int> scores = {'Math': 90, 'Science': 85};
  print('Initial scores: \$scores');

  // Add a new entry or update existing
  scores['English'] = 92; // Adds 'English': 92
  print('After adding English: \$scores');

  scores['Math'] = 95; // Updates 'Math' to 95
  print('After updating Math: \$scores');

  // putIfAbsent
  scores.putIfAbsent('History', () => 88); // Add 'History' only if it's not there
  print('After putIfAbsent (History): \$scores');

  scores.putIfAbsent('Math', () => 100); // Try to add 'Math' again - it won't change
  print('After putIfAbsent (Math again): \$scores');

  // addAll
  Map<String, int> moreScores = {'Art': 75, 'Science': 88}; // 'Science' will be updated
  scores.addAll(moreScores);
  print('After addAll: \$scores');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Adding a new contact to your phone book. If the contact already exists, you might update their number.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <ol class="list-decimal list-inside space-y-2">
                                <li>Create an empty Map <code>productPrices</code> (String key, double value).</li>
                                <li>Add "Apple" with price 0.50.</li>
                                <li>Add "Banana" with price 0.30.</li>
                                <li>Update the price of "Apple" to 0.55.</li>
                                <li>Use <code>putIfAbsent</code> to add "Orange" with price 0.40.</li>
                                <li>Print the map after each step.</li>
                            </ol>
                        </div>`
          },
          {
            id: "maps-updating-key-value", title: "3.8 Updating Key-Value Pairs in a Map",
            content: `
                        <p>This is typically done using the <code>[] =</code> operator as shown above. If the key exists, its value is updated.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  Map<String, String> config = {'theme': 'light', 'fontSize': '12px'};
  print('Initial config: \$config');

  config['theme'] = 'dark'; // Update existing key
  print('Updated config: \$config');
}</code></pre>
                        </div>
                        <p>Another method is <code>update(key, (value) => newValue, ifAbsent: () => defaultValue)</code>, which gives more control.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  Map<String, int> itemCounts = {'apples': 5, 'bananas': 3};

  // Update 'apples' count, add 2
  itemCounts.update('apples', (value) => value + 2);
  print('Updated apples: \$itemCounts');

  // Try to update 'oranges', if not present, add it with count 10
  itemCounts.update('oranges', (value) => value + 1, ifAbsent: () => 10);
  print('Updated/Added oranges: \$itemCounts');

  // This would cause an error if 'grapes' is not present and no ifAbsent is provided:
  // itemCounts.update('grapes', (value) => value + 1);
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Changing a friend's phone number in your contacts.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Create a map <code>{'user': 'guest', 'level': 1}</code>. Update the 'level' to 2. Print the map.</p>
                        </div>`
          },
          {
            id: "maps-removing", title: "3.9 Removing Items from a Map",
            content: `
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>remove(key)</code>: Removes the key-value pair for the given key. Returns the value if the key was found, or <code>null</code> otherwise.</li>
                            <li><code>removeWhere((key, value) => test)</code>: Removes all entries for which the test function returns <code>true</code>.</li>
                            <li><code>clear()</code>: Removes all entries from the map.</li>
                        </ul>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  Map<String, String> settings = {
    'language': 'English',
    'timezone': 'GMT',
    'notifications': 'enabled'
  };
  print('Initial settings: \$settings');

  // remove()
  String? removedValue = settings.remove('timezone');
  print('After removing timezone: \$settings, Removed value: \$removedValue');

  // removeWhere()
  settings.removeWhere((key, value) => key == 'notifications' && value == 'enabled');
  print('After removeWhere: \$settings');

  // clear()
  settings.clear();
  print('After clear: \$settings, Is empty: \${settings.isEmpty}');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Deleting a contact from your phone book.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <ol class="list-decimal list-inside space-y-2">
                                <li>Create a map <code>{'id1': 'ProductA', 'id2': 'ProductB', 'id3': 'ProductC'}</code>.</li>
                                <li>Remove the entry with key 'id2'.</li>
                                <li>Print the map.</li>
                            </ol>
                        </div>`
          },
          {
            id: "maps-contains-key", title: "3.10 Checking if a Map Contains a Specific Key",
            content: `
                        <p>Use <code>containsKey(key)</code>.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  Map<String, double> productStock = {'Laptop': 10.0, 'Mouse': 50.0};

  print('Stock contains "Laptop"? \${productStock.containsKey('Laptop')}');   // true
  print('Stock contains "Keyboard"? \${productStock.containsKey('Keyboard')}'); // false
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Before trying to get a definition from a dictionary, you check if the word (key) actually exists in it.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Create a map of student IDs (int) to grades (String). Check if a student with ID 101 exists and print the result.</p>
                        </div>`
          },
          {
            id: "maps-looping", title: "3.11 Looping Through a Map",
            content: `
                        <p>You can iterate through a Map's keys, values, or entries (key-value pairs).</p>
                        <h4>Iterating over entries using <code>forEach</code>:</h4>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  Map<String, String> bookAuthors = {
    'The Hobbit': 'J.R.R. Tolkien',
    '1984': 'George Orwell'
  };

  bookAuthors.forEach((key, value) {
    print('Book: \$key, Author: \$value');
  });
}</code></pre>
                        </div>
                        <h4>Iterating over keys:</h4>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  Map<String, String> bookAuthors = {
    'The Hobbit': 'J.R.R. Tolkien',
    '1984': 'George Orwell'
  };

  for (String bookTitle in bookAuthors.keys) {
    print('Book Title: \$bookTitle (Author: \${bookAuthors[bookTitle]})');
  }
}</code></pre>
                        </div>
                        <h4>Iterating over values:</h4>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  Map<String, String> bookAuthors = {
    'The Hobbit': 'J.R.R. Tolkien',
    '1984': 'George Orwell'
  };

  for (String author in bookAuthors.values) {
    print('Author: \$author');
  }
}</code></pre>
                        </div>
                        <h4>Iterating over entries using <code>for-in</code> with <code>map.entries</code>:</h4>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  Map<String, String> bookAuthors = {
    'The Hobbit': 'J.R.R. Tolkien',
    '1984': 'George Orwell'
  };

  for (var entry in bookAuthors.entries) {
    print('Book (entry): \${entry.key}, Author (entry): \${entry.value}');
  }
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Going through your phone book contact by contact, perhaps to send a message to everyone.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Create a map of items in your room and their count (e.g., <code>'chair': 1, 'books': 50</code>). Loop through the map and print "I have [count] [item_name] in my room."</p>
                        </div>`
          },
          {
            id: "maps-keys-values-to-lists", title: "3.12 Converting Map Keys and Values to Separate Lists",
            content: `
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>keys.toList()</code>: Returns a List of all keys.</li>
                            <li><code>values.toList()</code>: Returns a List of all values.</li>
                        </ul>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  Map<String, int> cityPopulations = {
    'New York': 8399000,
    'London': 8982000,
    'Tokyo': 13960000
  };

  List<String> cities = cityPopulations.keys.toList();
  List<int> populations = cityPopulations.values.toList();

  print('Cities: \$cities');
  print('Populations: \$populations');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>From your phone book (Map), you want a separate list of just names, and another separate list of just phone numbers.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Create a map <code>{'apple': 2.0, 'banana': 1.5, 'orange': 3.0}</code> representing fruits and their prices.</p>
                            <ol class="list-decimal list-inside space-y-2">
                                <li>Get a list of all fruit names.</li>
                                <li>Get a list of all prices.</li>
                                <li>Print both lists.</li>
                            </ol>
                        </div>`
          },
          {
            id: "module3-practice", title: "Module 3: Practice Questions (Sets & Maps)",
            isPractice: true,
            content: `
                        <p>This covers Dart Collections (Part 1 and 2). Next, we'll dive into "Dart Functions".</p>
                        <ol class="list-decimal list-inside space-y-2 mt-4">
                            <li><strong>Set Operations:</strong> Given <code>Set<int> s1 = {1,2,3,4,5}</code> and <code>Set<int> s2 = {4,5,6,7,8}</code>. Find and print their union, intersection, and <code>s1.difference(s2)</code>.</li>
                            <li><strong>Map Inventory:</strong> Create a <code>Map<String, int> inventory</code> for items and their quantities. Add items, update quantities, remove an item, and check if an item exists. Print the inventory at each step.</li>
                            <li><strong>Iterating a Map:</strong> Create a map of country names to their capitals. Iterate through it and print "The capital of [Country] is [Capital]."</li>
                            <li><strong>Word Frequency Counter:</strong> Given a <code>List<String></code> of words (with duplicates), create a <code>Map<String, int></code> to store the frequency of each word.</li>
                        </ol>`
          }
        ]
      },
      module4: { // Corresponds to PDF Module 4
        title: "Module 4: Master on Dart Functions",
        introduction: "Functions are blocks of code that perform a specific task. They help organize your code, make it reusable, and improve readability. This module covers various aspects of functions in Dart, based on Module 4 of the PDF.",
        sections: [
          {
            id: "functions-why-what-how", title: "4.1 Why, What, and How of Functions",
            content: `
                        <h4>Why use functions?</h4>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><strong>Reusability:</strong> Write code once, use it many times.</li>
                            <li><strong>Organization:</strong> Break down complex problems into smaller, manageable pieces.</li>
                            <li><strong>Readability:</strong> Makes code easier to understand by giving meaningful names to blocks of logic.</li>
                            <li><strong>Modularity:</strong> Changes in one function don't necessarily affect others.</li>
                            <li><strong>Testing:</strong> Easier to test individual pieces of functionality.</li>
                        </ul>
                        <h4>What is a function?</h4>
                        <p>A named block of code that can be called (executed) by its name. It can take inputs (called parameters or arguments) and can optionally return an output (a value).</p>
                        <h4>How to define and use functions?</h4>
                        <p>You define a function with a return type (or <code>void</code> if it returns nothing), a name, a list of parameters in parentheses <code>()</code>, and the code block in curly braces <code>{}</code>. You use (call) a function by writing its name followed by parentheses <code>()</code>, providing any necessary arguments.</p>`
          },
          {
            id: "functions-use-cases", title: "4.2 Practical Use Cases of Functions",
            content: `
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li>Calculating the area of a rectangle.</li>
                            <li>Sending an email.</li>
                            <li>Validating user input.</li>
                            <li>Fetching data from a server.</li>
                            <li>Displaying a greeting message.</li>
                            <li>Sorting a list of items.</li>
                            <li>Any repeatable task or distinct piece of logic.</li>
                        </ul>`
          },
          {
            id: "simple-function", title: "4.3 Simple Function",
            content: `
                        <p>A function that doesn't take any parameters and doesn't return any value (returns <code>void</code>).</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>// Function definition
void greet() {
  print('Hello, Dart learner!');
  print('Welcome to functions.');
}

void main() {
  // Calling the function
  greet();
  greet(); // Call it again
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>A light switch. You "call" the switch (flip it). It performs an action (turns light on/off) but doesn't take input from you at that moment or give you something back directly.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Write a simple function called <code>printMyName</code> that prints your name to the console. Call this function from <code>main</code>.</p>
                        </div>`
          },
          {
            id: "parameterized-functions", title: "4.4 Parameterized Functions",
            content: `
                        <p>Functions can accept input values called parameters (or arguments when you call the function). This makes functions more flexible. Dart supports several types of parameters:</p>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><strong>Positional Parameters:</strong> The most common type. Arguments are passed in the order they are defined.</li>
                            <li><strong>Named Parameters:</strong> Arguments are passed by name, making the code more readable, especially with many parameters. They are optional by default unless marked <code>required</code>.</li>
                            <li><strong>Optional Positional Parameters:</strong> Positional parameters that can be omitted when calling the function.</li>
                            <li><strong>Default Parameter Values:</strong> Provide a default value for optional (named or positional) parameters if no argument is passed.</li>
                        </ul>
                        <h4>4.4.1 Positional Parameters</h4>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>// Function definition with positional parameters
void introduce(String name, int age) {
  print('Hello, my name is \$name and I am \$age years old.');
}

void main() {
  // Calling the function with arguments
  introduce('Alice', 30);
  introduce('Bob', 25);
}</code></pre>
                        </div>
                        <p>The order of arguments ('Alice', 30) matters.</p>
                        <h4>4.4.2 Named Parameters</h4>
                        <p>Named parameters are enclosed in curly braces <code>{}</code> in the function definition. They are optional by default.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>// Function with named parameters
// Note: name and age are nullable (String? int?) because they are optional by default
void printUserDetails({String? name, int? age}) {
  print('User Details:');
  if (name != null) {
    print('  Name: \$name');
  }
  if (age != null) {
    print('  Age: \$age');
  }
}

// Using 'required' keyword for non-nullable named parameters
void printProduct({required String productName, required double price, String? category}) {
  print('Product: \$productName, Price: \\\$price');
  if (category != null) {
    print('  Category: \$category');
  }
}

void main() {
  printUserDetails(name: 'Charlie', age: 22);
  printUserDetails(age: 40); // Name is omitted, will be null
  printUserDetails(name: 'David'); // Age is omitted, will be null
  printUserDetails(); // Both omitted

  printProduct(productName: 'Laptop', price: 1200.00);
  printProduct(productName: 'Mouse', price: 25.00, category: 'Electronics');
  // printProduct(price: 25.00); // ERROR: productName is required
}</code></pre>
                        </div>
                        <p>With named parameters, the order of arguments doesn't matter.</p>
                        <h4>4.4.3 Optional Positional Parameters</h4>
                        <p>Optional positional parameters are enclosed in square brackets <code>[]</code> in the function definition. They must come after any required positional parameters.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>// Function with optional positional parameters
// city and country are nullable because they are optional
void displayAddress(String street, [String? city, String? country]) {
  String address = street;
  if (city != null) {
    address += ', \$city';
  }
  if (country != null) {
    address += ', \$country';
  }
  print('Address: \$address');
}

void main() {
  displayAddress('123 Main St');
  displayAddress('456 Oak Ave', 'Springfield');
  displayAddress('789 Pine Ln', 'Metropolis', 'USA');
}</code></pre>
                        </div>
                        <h4>4.4.4 Default Parameter Values</h4>
                        <p>You can assign default values to optional named or optional positional parameters. If an argument isn't provided for that parameter, the default value is used.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>// Default values for named parameters
void setupProfile({String name = 'Guest', bool notificationsEnabled = true}) {
  print('Profile for \$name. Notifications: \$notificationsEnabled');
}

// Default values for optional positional parameters
void makeCoffee([String type = 'Espresso', int sugarSpoons = 0]) {
  print('Making \$type with \$sugarSpoons spoon(s) of sugar.');
}

void main() {
  setupProfile(); // Uses default values
  setupProfile(name: 'Eve');
  setupProfile(notificationsEnabled: false);
  setupProfile(name: 'Frank', notificationsEnabled: false);

  makeCoffee(); // Uses default values
  makeCoffee('Latte');
  makeCoffee('Cappuccino', 1);
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example (Parameterized Function):</h4>
                            <p>A coffee machine (function). You provide inputs (parameters) like type of coffee ('Espresso', 'Latte') and sugar amount.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <ol class="list-decimal list-inside space-y-2">
                                <li>Write a function <code>addNumbers</code> that takes two <code>int</code> positional parameters and prints their sum.</li>
                                <li>Write a function <code>sendEmail</code> with named parameters: <code>to</code> (required String), <code>subject</code> (String, default "No Subject"), and <code>body</code> (required String). Print the details.</li>
                                <li>Call both functions from <code>main</code> with different arguments.</li>
                            </ol>
                        </div>`
          },
          {
            id: "lambda-anonymous-functions", title: "4.5 Lambda (Anonymous) Functions",
            content: `
                        <p>An anonymous function is a function without a name. A lambda function is a concise way to write an anonymous function, often used for simple operations. They are frequently used as arguments to other functions (like in <code>forEach</code> or <code>sort</code>).</p>
                        <p><strong>Syntax (Lambda/Arrow Function):</strong> <code>(parameters) => expression;</code></p>
                        <p>This is shorthand for: <code>(parameters) { return expression; }</code></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  List<String> names = ['alice', 'bob', 'charlie'];

  // Using a named function with forEach
  void printName(String name) {
    print(name.toUpperCase());
  }
  names.forEach(printName);

  print('--- Using Anonymous Function ---');
  // Using an anonymous function with forEach
  names.forEach((String name) {
    print(name.toUpperCase());
  });

  print('--- Using Lambda/Arrow Function ---');
  // Using a lambda function (arrow function) with forEach
  names.forEach((String name) => print(name.toUpperCase()));

  // Assigning a lambda to a variable
  var multiply = (int a, int b) => a * b;
  print('Product of 3 and 4: \${multiply(3, 4)}'); // Output: 12

  Function sum = (int a, int b) { // A more verbose anonymous function
    return a + b;
  };
  print('Sum of 5 and 6: \${sum(5,6)}');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>A quick, unnamed instruction you give someone for a one-time task, like "pass the salt."</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Create a list of numbers <code>[1, 2, 3, 4, 5]</code>. Use <code>forEach</code> with a lambda function to print each number multiplied by 2.</p>
                        </div>`
          },
          {
            id: "async-functions-preview", title: "4.6 Asynchronous Functions (Preview)",
            content: `
                        <p>(Covered in more detail in Module 9: Asynchronous Programming)</p>
                        <p>Asynchronous functions are used for operations that might take some time to complete, like fetching data from the internet or reading a file. They allow your program to continue doing other work instead of freezing while waiting. They use <code>async</code>, <code>await</code>, <code>Future</code>.</p>
                        <p><strong>Brief Preview:</strong></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>// This function simulates a network request
Future<String> fetchData() async {
  // Simulate a delay
  await Future.delayed(Duration(seconds: 2));
  return 'Data fetched successfully!';
}

void main() async { // main can also be async
  print('Fetching data...');
  String result = await fetchData(); // Wait for fetchData to complete
  print(result);
  print('Program finished.');
}</code></pre>
                        </div>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>Future&lt;String&gt;</code>: Indicates the function will eventually return a String.</li>
                            <li><code>async</code>: Marks the function as asynchronous.</li>
                            <li><code>await</code>: Pauses execution within the <code>async</code> function until the Future completes.</li>
                        </ul>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Ordering food at a restaurant. You place your order (<code>await fetchData()</code>) and then you can talk to your friends (do other work) while the kitchen prepares your food. When the food is ready (Future completes), the waiter brings it to you.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise (Conceptual for now):</h4>
                            <p>Think about a real-world task that takes time and where you'd do something else while waiting (e.g., downloading a large file).</p>
                        </div>`
          },
          {
            id: "functions-return-types", title: "4.7 Functions with Return Types",
            content: `
                        <p>Functions can return a value to the code that called them using the <code>return</code> keyword. The type of the returned value must match the function's declared return type.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>// Function that returns an int
int add(int a, int b) {
  return a + b;
}

// Function that returns a String
String getGreeting(String name) {
  return 'Hello, \$name!';
}

// Function that returns a bool
bool isEven(int number) {
  return number % 2 == 0;
}

void main() {
  int sum = add(5, 3); // Call add and store the returned value
  print('Sum: \$sum');

  String message = getGreeting('Diana');
  print(message);

  if (isEven(4)) {
    print('4 is even.');
  } else {
    print('4 is odd.');
  }
}</code></pre>
                        </div>
                        <p>If a function has a return type other than <code>void</code> and <code>dynamic</code>, it must end with a <code>return</code> statement that returns a value of the correct type (or <code>throw</code> an exception).</p>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>A calculator's addition button. You give it two numbers (parameters), and it gives you back their sum (return value).</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Write a function <code>multiply</code> that takes two <code>double</code> parameters and returns their product (a <code>double</code>). Call it and print the result.</p>
                        </div>`
          },
          {
            id: "arrow-functions-shorthand", title: "4.8 Arrow Functions (Shorthand, Inline)",
            content: `
                        <p>This is the same as Lambda functions discussed in 4.5. If a function contains only one expression, you can use the arrow (<code>=></code>) syntax. It's a shorthand for <code>{ return expression; }</code>.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>// Traditional function
int squareTraditional(int x) {
  return x * x;
}

// Arrow function (shorthand)
int squareArrow(int x) => x * x;

// Arrow function with void return type
void printMessage(String msg) => print('Message: \$msg');

void main() {
  print('Square of 5 (traditional): \${squareTraditional(5)}');
  print('Square of 5 (arrow): \${squareArrow(5)}');
  printMessage('This is an arrow function example.');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>A very short, direct instruction, like pointing (<code>=></code>) to an object.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Rewrite the <code>multiply</code> function from the previous exercise using arrow syntax.</p>
                        </div>`
          },
          {
            id: "higher-order-callback-functions", title: "4.9 Higher-Order Functions / Callback Functions",
            content: `
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><strong>Higher-Order Function:</strong> A function that either:
                                <ol class="list-decimal list-inside ml-4">
                                    <li>Takes one or more functions as arguments.</li>
                                    <li>Returns a function as its result.</li>
                                </ol>
                                Examples: <code>list.forEach((element) {})</code>, <code>list.map((e) => e*2)</code>, <code>list.where((e) => e > 2)</code>
                            </li>
                            <li><strong>Callback Function:</strong> A function that is passed as an argument to another function and is executed ("called back") by that other function at some point. The anonymous functions used with <code>forEach</code> or <code>sort</code> are callback functions.</li>
                        </ul>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>// Higher-order function that takes a function as an argument
void operateOnNumbers(int a, int b, Function(int, int) operation) {
  int result = operation(a, b);
  print('Result of operation: \$result');
}

// Callback functions
int sum(int x, int y) {
  return x + y;
}

int product(int x, int y) {
  return x * y;
}

// Higher-order function that returns a function
Function multiplier(int factor) {
  return (int number) => number * factor; // Returns an anonymous function
}

void main() {
  // Passing 'sum' and 'product' as callbacks
  operateOnNumbers(10, 5, sum);     // Output: Result of operation: 15
  operateOnNumbers(10, 5, product); // Output: Result of operation: 50

  // Passing a lambda as a callback
  operateOnNumbers(7, 3, (x, y) => x - y); // Output: Result of operation: 4

  // Using the function returned by 'multiplier'
  var doubler = multiplier(2); // doubler is now a function: (int number) => number * 2
  var tripler = multiplier(3); // tripler is now a function: (int number) => number * 3

  print('Double 7: \${doubler(7)}'); // Output: 14
  print('Triple 7: \${tripler(7)}'); // Output: 21
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example (Higher-Order Function):</h4>
                            <p>Imagine a manager (higher-order function) who tells an employee (callback function) what task to do on some data. The manager doesn't do the task itself but delegates it.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <ol class="list-decimal list-inside space-y-2">
                                <li>Create a list of names: <code>['Alice', 'Bob', 'CHARLIE', 'diana']</code>.</li>
                                <li>Use the <code>map</code> method (which is a higher-order function) with a lambda function to convert all names to lowercase. Store the result in a new list and print it. (<code>newNames = names.map((name) => name.toLowerCase()).toList();</code>)</li>
                                <li>Write a higher-order function <code>filterList</code> that takes a <code>List&lt;int&gt;</code> and a callback function <code>bool test(int)</code>. <code>filterList</code> should return a new list containing only numbers for which <code>test</code> returns true. Test it by filtering a list to get only even numbers.</li>
                            </ol>
                        </div>`
          },
          {
            id: "recursive-functions", title: "4.10 Recursive Functions",
            content: `
                        <p>A recursive function is a function that calls itself within its own definition. It's used to solve problems that can be broken down into smaller, self-similar subproblems. A recursive function must have:</p>
                        <ol class="list-decimal list-inside my-2 ml-4">
                            <li><strong>Base Case:</strong> A condition that stops the recursion (otherwise, it would call itself infinitely).</li>
                            <li><strong>Recursive Step:</strong> The part where the function calls itself with a modified argument, moving closer to the base case.</li>
                        </ol>
                        <p><strong>Example: Factorial</strong> (Factorial of n (n!) = n * (n-1) * ... * 1. Base case: 0! = 1, 1! = 1)</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>int factorial(int n) {
  // Base case
  if (n <= 1) {
    return 1;
  }
  // Recursive step
  else {
    return n * factorial(n - 1);
  }
}

void main() {
  print('Factorial of 5: \${factorial(5)}'); // Output: 120
  print('Factorial of 0: \${factorial(0)}'); // Output: 1
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Russian nesting dolls. Each doll (except the smallest) contains a smaller version of itself. Opening a doll is like a recursive step. The smallest doll is the base case.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Write a recursive function to calculate the sum of numbers from 1 to <code>n</code>. For example, <code>sumRecursive(3)</code> should return 3 + 2 + 1 = 6. Base case: if <code>n <= 0</code>, return 0. Recursive step: <code>return n + sumRecursive(n - 1);</code></p>
                        </div>`
          },
          {
            id: "module4-practice", title: "Module 4: Practice Questions (Functions)",
            isPractice: true,
            content: `
                        <p>This covers Dart Functions. Next is "File and Exception Handling".</p>
                        <ol class="list-decimal list-inside space-y-2 mt-4">
                            <li><strong>Temperature Converter:</strong> Write two functions: <code>celsiusToFahrenheit(double celsius)</code> and <code>fahrenheitToCelsius(double fahrenheit)</code>. Use arrow syntax.</li>
                            <li><strong>User Greeter:</strong> Create a function <code>greetUser({required String name, String greeting = "Hello"})</code> that prints a personalized greeting.</li>
                            <li><strong>List Processor:</strong> Write a higher-order function <code>processList(List<int> numbers, int Function(int) action)</code> that applies the <code>action</code> function to each number in the list and returns a new list with the results. Test it by passing a lambda that doubles each number.</li>
                            <li><strong>Recursive Countdown:</strong> Write a recursive function <code>countdown(int n)</code> that prints numbers from <code>n</code> down to 1, then prints "Liftoff!". If <code>n</code> is 0 or less, it should just print "Liftoff!".</li>
                        </ol>`
          }
        ]
      },
      module5: { // Corresponds to PDF Module 5
        title: "Module 5: File and Exception Handling",
        introduction: "This module covers how to work with files (reading, writing, etc.) using <code>dart:io</code> and how to handle errors and unexpected situations (exceptions) in your Dart programs. This is based on Module 5 of the PDF.",
        sections: [
          {
            id: "dart-io-library", title: "5.1 Working with dart:io Library",
            content: `
                        <p>The <code>dart:io</code> library provides APIs to work with files, directories, processes, sockets, HTTP servers and clients, etc.</p>
                        <div class="note"><p><strong>Important:</strong> <code>dart:io</code> is NOT available in web environments (like DartPad when running for the web, or Flutter web). It's primarily for command-line applications, server-side Dart, and Flutter mobile/desktop apps. For web, you use different APIs (like <code>dart:html</code> or browser-specific JavaScript interop).</p></div>
                        <p>To use it, you first need to import it: <code>import 'dart:io';</code></p>`
          },
          {
            id: "reading-writing-files", title: "5.2 Reading and Writing Files",
            content: `
                        <p>We'll use <code>File</code> objects from <code>dart:io</code>. Most file operations are asynchronous and return <code>Future</code>s.</p>
                        <h4>Writing to a File:</h4>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>import 'dart:io';

Future<void> main() async {
  var myFile = File('my_document.txt'); // Creates a reference

  try {
    // Write content (overwrites or creates)
    await myFile.writeAsString('Hello from Dart!\\nThis is a new line.');
    print('File written successfully.');

    // Append content
    await myFile.writeAsString('\\nAppending more text.', mode: FileMode.append);
    print('Content appended successfully.');
  } catch (e) {
    print('An error occurred while writing to the file: \$e');
  }
}</code></pre>
                        </div>
                        <h4>Reading from a File:</h4>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>import 'dart:io';

Future<void> main() async {
  var myFile = File('my_document.txt');

  try {
    if (await myFile.exists()) {
      String contents = await myFile.readAsString();
      print('File content:\\n\$contents');

      List<String> lines = await myFile.readAsLines();
      print('\\nFile content as lines:');
      for (String line in lines) {
        print('- \$line');
      }
    } else {
      print('File does not exist.');
    }
  } catch (e) {
    print('An error occurred while reading the file: \$e');
  }
}</code></pre>
                        </div>
                        <div class="note"><p>For these examples to run, you'd typically execute them as a Dart script from your terminal, not directly in DartPad (unless DartPad's server-side execution supports <code>dart:io</code>).</p></div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Writing a letter (string) and saving it in an envelope (file). Later, opening the envelope to read the letter.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise (Conceptual if not using local Dart SDK):</h4>
                            <ol class="list-decimal list-inside space-y-2">
                                <li>Imagine you want to write a list of your favorite books to a file named <code>books.txt</code>.</li>
                                <li>Then, imagine reading that file and printing each book title.</li>
                            </ol>
                        </div>`
          },
          {
            id: "file-operations", title: "5.3 Deleting, Renaming Files, and Checking Existence",
            content: `
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>file.exists()</code>: Returns a <code>Future&lt;bool&gt;</code> indicating if the file exists.</li>
                            <li><code>file.delete()</code>: Returns a <code>Future&lt;FileSystemEntity&gt;</code>. Throws an error if it fails.</li>
                            <li><code>file.rename(newPath)</code>: Returns a <code>Future&lt;File&gt;</code>.</li>
                        </ul>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>import 'dart:io';

Future<void> main() async {
  var file = File('temp_file.txt');
  var renamedFile = File('renamed_temp_file.txt');

  try {
    await file.writeAsString('Temporary content.');
    print('File created: \${file.path}');

    if (await file.exists()) {
      print('\${file.path} exists.');
      await file.rename(renamedFile.path);
      print('\${file.path} renamed to \${renamedFile.path}');

      if (await renamedFile.exists()) {
         print('\${renamedFile.path} now exists.');
         await renamedFile.delete();
         print('\${renamedFile.path} deleted.');
      }
    }
  } catch (e) {
    print('Error: \$e');
  }
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Throwing an old document in the trash (delete). Changing the label on a folder (rename). Checking if you have a specific document (exists).</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise (Conceptual):</h4>
                            <p>Describe the steps to: Create <code>draft.txt</code>, check existence, rename to <code>final_version.txt</code>, delete <code>final_version.txt</code>.</p>
                        </div>`
          },
          {
            id: "directory-operations", title: "5.4 Creating and Deleting Directories",
            content: `
                        <p>Use the <code>Directory</code> class from <code>dart:io</code>.</p>
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>directory.create()</code>: Creates the directory. <code>create(recursive: true)</code> creates parent directories if they don't exist.</li>
                            <li><code>directory.delete()</code>: Deletes the directory. <code>delete(recursive: true)</code> deletes the directory and its contents.</li>
                        </ul>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>import 'dart:io';

Future<void> main() async {
  var newDir = Directory('my_new_folder');
  var nestedDir = Directory('my_new_folder/level1/level2');

  try {
    if (!await newDir.exists()) {
      await newDir.create();
      print('Directory created: \${newDir.path}');
    }
    if(!await nestedDir.exists()){
        await nestedDir.create(recursive: true);
        print('Nested directory created: \${nestedDir.path}');
    }
    // Delete (use recursive: true for non-empty)
    if (await nestedDir.exists()) {
        await nestedDir.delete(recursive: true);
        print('Directory deleted: \${nestedDir.path}');
    }
    if (await newDir.exists()) {
      await newDir.delete(recursive: true);
      print('Directory deleted: \${newDir.path}');
    }
  } catch (e) {
    print('Error: \$e');
  }
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Creating a new folder on your computer (create). Deleting a folder (delete).</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise (Conceptual):</h4>
                            <p>How would you create a directory structure like <code>projects/dart_apps/my_app</code>? How would you delete the <code>my_app</code> directory?</p>
                        </div>`
          },
          {
            id: "listing-files", title: "5.5 Listing Files in a Directory",
            content: `
                        <p>Use <code>directory.list()</code> or <code>directory.listSync()</code>. <code>list()</code> returns a <code>Stream&lt;FileSystemEntity&gt;</code> objects (files, directories, links).</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>import 'dart:io';

Future<void> main() async {
  var currentDir = Directory.current;
  print('Listing contents of \${currentDir.path}:');

  try {
    // Create dummy files/dirs for listing (ensure cleanup)
    await File('\${currentDir.path}/file1.txt').writeAsString('content1');
    await Directory('\${currentDir.path}/temp_dir').create();

    Stream<FileSystemEntity> entityStream = currentDir.list(recursive: false, followLinks: false);
    await for (FileSystemEntity entity in entityStream) {
      String type = entity is File ? 'File' : (entity is Directory ? 'Directory' : 'Link');
      print('\$type: \${entity.path}');
    }
    // Cleanup
    await File('\${currentDir.path}/file1.txt').delete();
    await Directory('\${currentDir.path}/temp_dir').delete();
  } catch (e) {
    print('Error listing directory: \$e');
  }
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Opening a folder on your computer and seeing all the files and subfolders inside it.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise (Conceptual):</h4>
                            <p>If you have a directory <code>my_photos</code> with <code>photo1.jpg</code>, <code>photo2.png</code>, and a subdirectory <code>vacation_pics</code>, what would <code>directory.list()</code> show? What if <code>recursive: true</code>?</p>
                        </div>`
          },
          {
            id: "file-paths", title: "5.6 Working with File Paths",
            content: `
                        <p>The <code>path</code> package (add to <code>pubspec.yaml</code>) is very useful for manipulating file paths in a platform-independent way. <code>dart:io</code> also provides some basic path properties.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>import 'dart:io';
// import 'package:path/path.dart' as p; // Requires pubspec.yaml setup

void main() {
  var myFile = File('project/data/report.txt');
  print('Path from File object: \${myFile.path}');
  print('Absolute path: \${myFile.absolute.path}');
  print('Parent directory: \${myFile.parent.path}');

  // Using path package (conceptual if not setup)
  // String fullPath = '/users/home/file.txt';
  // print('\\nUsing path package:');
  // print('Basename: \${p.basename(fullPath)}');
  // print('Dirname: \${p.dirname(fullPath)}');
  // print('Extension: \${p.extension(fullPath)}');
  // String joinedPath = p.join('directory1', 'subdirectory', 'file.json');
  // print('Joined path: \$joinedPath');
}</code></pre>
                        </div>
                        <div class="note"><p>To use the <code>path</code> package in a local Dart project, add <code>path: ^version</code> to your <code>pubspec.yaml</code> under dependencies, then run <code>dart pub get</code>.</p></div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Knowing the full address of a house (absolute path), or just the street name (basename). Combining a city and street name to form a full address (joining paths).</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise (Conceptual):</h4>
                            <p>Given the path <code>C:\\Users\\YourName\\Documents\\notes.md</code>: What is the basename, directory name, and extension?</p>
                        </div>`
          },
          {
            id: "exception-vs-error", title: "5.7 Exception vs. Error",
            content: `
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><strong>Error:</strong> Represents a serious problem that a program usually cannot recover from (e.g., <code>OutOfMemoryError</code>, <code>StackOverflowError</code>). Generally, don't try to catch Errors.</li>
                            <li><strong>Exception:</strong> Represents a less severe problem that a program might be able to recover from (e.g., <code>FormatException</code>, <code>FileSystemException</code>). You are encouraged to catch and handle Exceptions.</li>
                        </ul>
                        <p>Dart allows you to <code>throw</code> and <code>catch</code> any non-null object, but it's good practice to throw objects that implement <code>Exception</code> or <code>Error</code>.</p>`
          },
          {
            id: "try-catch", title: "5.8 Error Handling with try-catch",
            content: `
                        <p>Used to handle exceptions gracefully and prevent your program from crashing.</p>
                        <p><strong>Syntax:</strong></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>try {
  // Code that might throw an exception
} catch (e) {
  // Code to handle ANY type of exception
  // 'e' is the exception object
}</code></pre>
                        </div>
                        <p><strong>Example:</strong></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  String input = 'hello'; // Try changing to '123'
  int number;
  try {
    number = int.parse(input); // This can throw a FormatException
    print('Parsed number: \$number');
  } catch (e) {
    print('Oops! An exception occurred: \$e');
    print('Could not parse "\$input" into an integer.');
    number = 0; // Provide a default value
  }
  print('Program continues with number = \$number');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Trying to make a phone call (<code>try</code>). If the network is down (exception), you get an error message (<code>catch</code>) instead of your phone exploding.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Write code that tries to divide 10 by 0. Wrap it in a <code>try-catch</code> block to catch the <code>IntegerDivisionByZeroException</code> (or more generally <code>UnsupportedError</code>) and print a friendly error message.</p>
                        </div>`
          },
          {
            id: "on-vs-catch", title: "5.9 on vs. catch for Specific Exceptions",
            content: `
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>on ExceptionType</code>: Catches only exceptions of a specific type.</li>
                            <li><code>catch (e)</code>: Catches any exception.</li>
                            <li><code>catch (e, s)</code>: Catches any exception and also provides the stack trace (<code>s</code>), which helps in debugging.</li>
                        </ul>
                        <p>You can have multiple <code>on</code> clauses, followed by an optional generic <code>catch</code>.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  String value = 'abc'; // Try '12.34x', '0', '56'
  try {
    int result = 100 ~/ int.parse(value);
    print('Result: \$result');
  } on FormatException catch (e) {
    print('Specific Handler: Invalid format. Details: \$e');
  } on IntegerDivisionByZeroException catch (e) { // More specific than UnsupportedError
    print('Specific Handler: Cannot divide by zero! Details: \$e');
  } catch (e, s) { // General catch-all
    print('Generic Handler: An unexpected error: \$e');
    // print('Stack trace:\\n\$s');
  }
  print('Program continues...');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>If your car has a problem (<code>try</code>):<br>
                            ● <code>on FlatTireException</code>: Change the tire.<br>
                            ● <code>on EmptyFuelException</code>: Go to a gas station.<br>
                            ● <code>catch (anyOtherProblem)</code>: Call a mechanic.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Modify the previous division exercise. Add a specific <code>on IntegerDivisionByZeroException</code> handler and a general <code>catch (e)</code> handler. Test with dividing by zero and also by trying <code>int.parse("xyz")</code> inside the <code>try</code> block to see which handler catches what.</p>
                        </div>`
          },
          {
            id: "finally-block", title: "5.10 finally Block",
            content: `
                        <p>The <code>finally</code> block always executes, whether an exception occurred or not. It's typically used for cleanup code (e.g., closing files, releasing resources).</p>
                        <p><strong>Syntax:</strong></p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>try {
  // Risky code
} catch (e) {
  // Handle exception
} finally {
  // Cleanup code - always runs
}</code></pre>
                        </div>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>void main() {
  bool resourceOpen = false;
  try {
    print('Trying to use a resource...');
    resourceOpen = true; // Resource is "opened"
    // int result = 10 ~/ 0; // Uncomment to cause an exception
    print('Resource used successfully.');
  } catch (e) {
    print('Exception caught: \$e');
  } finally {
    print('Finally block executing.');
    if (resourceOpen) {
      print('Cleaning up / Closing resource...');
      resourceOpen = false;
    }
  }
  print('Program finished.');
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>You borrow a library book (<code>try</code> to read it). Whether you finish reading it or spill coffee on it (exception), you <code>finally</code> have to return the book to the library.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Write a <code>try-catch-finally</code> block. Inside <code>try</code>, print "Trying operation". Inside <code>catch</code>, print "Caught error". Inside <code>finally</code>, print "Operation finished". Test it once without causing an error in <code>try</code>, and once by causing an error (e.g., <code>throw Exception('Test error');</code>).</p>
                        </div>`
          },
          {
            id: "throwing-custom-exceptions", title: "5.11 Throwing Custom Exceptions",
            content: `
                        <p>You can define your own custom exception classes by implementing the <code>Exception</code> interface (or extending an existing exception class). This makes your error handling more specific and meaningful.</p>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>// Custom exception class
class InsufficientFundsException implements Exception {
  final String message;
  InsufficientFundsException([this.message = 'Not enough funds.']);
  @override
  String toString() => 'InsufficientFundsException: \$message';
}

class Account {
  double balance;
  Account(this.balance);

  void withdraw(double amount) {
    if (amount > balance) {
      throw InsufficientFundsException('Cannot withdraw \\\$amount, balance is only \\\$balance.');
    }
    if (amount < 0) {
      throw ArgumentError('Withdrawal amount cannot be negative.');
    }
    balance -= amount;
    print('Withdrew \\\$amount. New balance: \\\$balance');
  }
}

void main() {
  var myAccount = Account(100.0);
  try {
    myAccount.withdraw(50.0);
    myAccount.withdraw(70.0); // This will throw
  } on InsufficientFundsException catch (e) {
    print('Error: \${e.message}');
  } on ArgumentError catch (e) {
    print('Invalid argument: \${e.message}');
  } finally {
    print('Transaction attempt finished. Balance: \${myAccount.balance}');
  }
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>A coffee machine might have a custom <code>OutOfBeansException</code> or <code>WaterTankEmptyException</code>.</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Create a custom exception <code>InvalidAgeException</code>. Write a function <code>registerUser(String name, int age)</code> that throws this exception if age is less than 18. Call this function in a <code>try-catch</code> block.</p>
                        </div>`
          },
          {
            id: "async-error-handling", title: "5.12 Asynchronous Error Handling",
            content: `
                        <p>When working with <code>async</code> functions and <code>Future</code>s, errors are propagated as <code>Future</code>s that complete with an error. You can handle them using <code>try-catch</code> with <code>await</code>, or by using the <code>catchError</code> method on a <code>Future</code>.</p>
                        <h4>Using <code>try-catch</code> with <code>await</code> (preferred):</h4>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>Future<String> fetchData(bool succeed) async {
  await Future.delayed(Duration(seconds: 1));
  if (succeed) {
    return 'Data fetched!';
  } else {
    throw Exception('Network error - failed to fetch data.');
  }
}

Future<void> main() async {
  print('Attempting to fetch data (will succeed)...');
  try {
    String result = await fetchData(true);
    print('Success: \$result');
  } catch (e) {
    print('Caught error: \$e');
  }

  print('\\nAttempting to fetch data (will fail)...');
  try {
    String result = await fetchData(false);
    print('Success: \$result'); // This won't be reached
  } catch (e) {
    print('Caught error: \$e');
  }
}</code></pre>
                        </div>
                        <h4>Using <code>Future.catchError()</code>:</h4>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code>Future<String> fetchDataWithCatchError(bool succeed) {
  return Future.delayed(Duration(seconds: 1), () {
    if (succeed) {
      return 'Data via catchError!';
    } else {
      throw Exception('Network error for catchError.');
    }
  });
}

void main() {
  print('Using Future.catchError (will fail):');
  fetchDataWithCatchError(false)
    .then((data) {
      print('Success: \$data');
    })
    .catchError((error) {
      print('Caught with .catchError: \$error');
    });
}</code></pre>
                        </div>
                        <div class="real-life-example">
                            <h4>Real-life Example:</h4>
                            <p>Ordering a package online (<code>Future</code>). If there's a shipping issue (exception in <code>Future</code>), the system notifies you (<code>catchError</code> or <code>try-catch</code>).</p>
                        </div>
                        <div class="exercise-block">
                            <h4>Exercise:</h4>
                            <p>Create an <code>async</code> function <code>readFileContent(String filePath)</code> that simulates reading a file. If <code>filePath</code> is "valid.txt", return "File content". If it's anything else, <code>throw Exception("File not found")</code>. Call this function with both a valid and an invalid path, handling errors using <code>try-catch</code> with <code>await</code>.</p>
                        </div>`
          },
          {
            id: "module5-practice", title: "Module 5: Practice Questions (File IO & Exceptions)",
            isPractice: true,
            content: `
                        <p>Next is Object-Oriented Programming (Part 1). This is a big topic!</p>
                        <ol class="list-decimal list-inside space-y-2 mt-4">
                            <li><strong>File Logger (Conceptual for DartPad):</strong> Imagine a function <code>logToFile(String message, String fileName)</code> that appends a message to a specified file. How would you handle potential <code>FileSystemException</code>s if the file cannot be written to?</li>
                            <li><strong>Number Parser with Robust Error Handling:</strong> Write a function <code>int parseStrictInt(String input)</code>. It should:
                                <ul class="list-disc list-inside ml-4">
                                    <li>Throw an <code>ArgumentError</code> if the input is empty.</li>
                                    <li>Attempt to parse the input to an integer.</li>
                                    <li>Catch <code>FormatException</code> and print a user-friendly message.</li>
                                    <li>Use a <code>finally</code> block to print "Parsing attempt finished."</li>
                                </ul>
                                Test with valid numbers, invalid strings, and an empty string.
                            </li>
                            <li><strong>Async Data Fetcher with Custom Error:</strong> Create <code>Future&lt;Map&lt;String, dynamic&gt;&gt; fetchRemoteConfig() async</code>. Simulate a delay. If a random number is even, return <code>{'setting': 'enabled'}</code>. If odd, throw a custom <code>ConfigFetchException('Server timeout')</code>. Call this in <code>main</code> and handle both success and your custom exception.</li>
                        </ol>`
          }
        ]
      },
      module6: {
        title: "Module 6: Master on Object-Oriented Programming (Part 1)",
        introduction: "Object-Oriented Programming (OOP) is a programming paradigm based on the concept of \"objects\", which can contain data (fields) and code (methods). Dart is an object-oriented language where everything is an object, and all objects are instances of classes, inheriting from the base class `Object`. This module covers the fundamentals of OOP in Dart.",
        sections: [
          {
            id: "oop-dart-overview",
            title: "6.1 Dart Object-Oriented Programming",
            content: `
                <p>Dart is a true object-oriented language, meaning that even functions, numbers, and null are objects. All objects are instances of a class, and all classes descend from the top-level class <code>Object</code>.</p>
                <h4>Core OOP Concepts in Dart:</h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong>Classes:</strong> Blueprints for creating objects.</li>
                    <li><strong>Objects:</strong> Instances of classes.</li>
                    <li><strong>Encapsulation:</strong> Bundling data (attributes) and methods that operate on the data within a single unit (class. It involves hiding internal state and requiring interaction through an object's public interface.</li>
                    <li><strong>Inheritance:</strong> Allowing a new class (subclass) to inherit properties and methods from an existing class (superclass. This promotes code reuse.</li>
                    <li><strong>Polymorphism:</strong> Meaning "many forms", it allows objects of different classes to be treated as objects of a common superclass. The same method call can behave differently depending on the object it's called on.</li>
                </ul>`
          },
          {
            id: "dart-class-object",
            title: "6.2 Dart Class and Object",
            content: `
                <p>A <strong>Class</strong> is a blueprint or template for creating objects. It defines the properties (data) and methods (behavior) that all objects of that class will have. It's defined using the <code>class ClassName { ... }</code> syntax.</p>
                <p>An <strong>Object</strong> is an instance of a class. It's a concrete entity created from a class blueprint, with its own state (values for its properties. Objects are typically created using a constructor, and the <code>new</code> keyword is optional in Dart.</p>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>// Class definition 
class Dog {
  // Instance Variables (Properties / Fields / Attributes)
  String name;
  String breed;
  int age;
  bool isFriendly;

  // Constructor (simple version) 
  // Dog(String name, String breed, int age, bool isFriendly)
  //     : this.name = name,
  //       this.breed = breed,
  //       this.age = age,
  //       this.isFriendly = isFriendly;

  // A more concise way to write the above constructor (syntactic sugar): 
  Dog(this.name, this.breed, this.age, this.isFriendly);

  // Methods (Behavior) 
  void bark() {
    print('\$name says: Woof woof!');
  }

  void fetch(String item) {
    print('\$name is fetching the \$item.');
  }

  void displayInfo() {
    print('Dog Info: Name: \$name, Breed: \$breed, Age: \$age, Friendly: \$isFriendly');
  }
} // End of Dog class 

void main() {
  // Creating Objects (Instances of the Dog class)
  Dog myDog = Dog('Buddy', 'Golden Retriever', 3, true); // 'new' is optional 
  Dog neighborsDog = Dog('Lucy', 'Poodle', 5, true);
  Dog strayDog = Dog('Rocky', 'Unknown', 2, false); 

  // Accessing properties and calling methods
  print('My dog\\'s name is \${myDog.name}.'); 
  myDog.bark(); 
  myDog.fetch('ball'); 
  myDog.displayInfo(); 

  print('\\nNeighbor\\'s dog:');
  neighborsDog.displayInfo();
  neighborsDog.bark();

  print('\\nStray dog:');
  strayDog.displayInfo();
  if(strayDog.isFriendly){
    print('\${strayDog.name} is friendly.');
  } else {
    print('\${strayDog.name} might not be friendly, approach with caution.'); 
  }
}</code></pre>
                </div>
                <div class="real-life-example">
                    <h4>Real-life Example:</h4>
                    <p>A <strong>Class</strong> is like the blueprint for a "Car," defining properties (color, model) and methods (startEngine(), accelerate. An <strong>Object</strong> is your specific red Toyota Camry, an instance of the Car class.</p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <ol class="list-decimal list-inside space-y-1">
                        <li>Define a class <code>Book</code> with properties: <code>title</code> (String), <code>author</code> (String), and <code>numberOfPages</code> (int).</li>
                        <li>Add a method <code>displayBookInfo()</code> that prints all the book's details.</li>
                        <li>In <code>main()</code>, create two <code>Book</code> objects with different details and call <code>displayBookInfo()</code> for each.</li>
                    </ol>
                </div>`
          },
          {
            id: "constructors-detailed-m6",
            title: "6.3 Constructor Detailed",
            content: `
                <p>A constructor is a special method used to create and initialize objects of a class. It has the same name as the class and no explicit return type.</p>
                <h4>Types of Constructors:</h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong>Default Constructor:</strong> If no constructor is defined, Dart provides a default no-argument constructor (if there are no final fields needing initialization).
                        <div class="code-block"><button class="copy-button">Copy</button><pre><code>class Chair {
  String? material; // If no constructor, material would be null
}
// var myChair = Chair(); // Uses default constructor </code></pre></div>
                    </li>
                    <li><strong>Generative Constructors:</strong> The primary way to create instances.
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><strong>Short-form (Syntactic Sugar):</strong> Most common. <code>Point(this.x, this.y);</code>. This initializes instance variable <code>x</code> with parameter <code>x</code.</li>
                            <li><strong>Long-form:</strong> Explicitly assigning parameters to instance variables.
                                <div class="code-block"><button class="copy-button">Copy</button><pre><code>class PointLong {
  double x;
  double y;
  PointLong(double xValue, double yValue) { // 
    this.x = xValue;
    this.y = yValue;
  }
}</code></pre></div>
                            </li>
                            <li><strong>Initializer List:</strong> Executes before the constructor body, useful for final fields or complex initialization. Syntax: <code>ClassName(...) : field = value { ... }</code>.
                                <div class="code-block"><button class="copy-button">Copy</button><pre><code>class Rectangle {
  final double left, top, width, height;
  final double area;
  Rectangle(this.left, this.top, this.width, this.height)
      : area = width * height { // Initializer list 
    print('Rectangle created with area: \$area');
  }
}
// var rect = Rectangle(0, 0, 10, 5); </code></pre></div>
                            </li>
                        </ul>
                    </li>
                    <li><strong>Named Constructors:</strong> Allow multiple ways to create objects, using <code>ClassName.constructorName()</code.
                        <div class="code-block"><button class="copy-button">Copy</button><pre><code>class Color {
  int red, green, blue;
  Color(this.red, this.green, this.blue); // Primary constructor 
  Color.black() : red = 0, green = 0, blue = 0; // Named constructor 
  Color.white() { red = 255; green = 255; blue = 255; } // 
  Color.fromHex(String hexCode) // 
    : red = int.parse(hexCode.substring(1, 3), radix: 16),
      green = int.parse(hexCode.substring(3, 5), radix: 16),
      blue = int.parse(hexCode.substring(5, 7), radix: 16);
}
// Usage: var blackColor = Color.black(); </code></pre></div>
                    </li>
                    <li><strong>Constant Constructors:</strong> For objects that never change (immutable). Class must have only <code>final</code> fields. Use <code>const ClassName(...)</code>. Creates compile-time constants for performance.
                        <div class="code-block"><button class="copy-button">Copy</button><pre><code>class ImmutablePoint {
  final double x, y;
  const ImmutablePoint(this.x, this.y); // 
}
// const p1 = ImmutablePoint(1, 2);
// const p2 = ImmutablePoint(1, 2); // identical(p1,p2) is true </code></pre></div>
                    </li>
                    <li><strong>Factory Constructors:</strong> (Covered more in Advanced OOP ) Doesn't always create a new instance; can return from cache or a subtype. Keyword <code>factory</code>.</li>
                </ul>
                <div class="real-life-example">
                    <h4>Real-life Example (Named Constructor):</h4>
                    <p>Ordering a pizza: <code>Pizza('Pepperoni', 'Large')</code> (primary) vs. <code>Pizza.vegetarianDelight('Medium')</code> (named.</p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <ol class="list-decimal list-inside space-y-1">
                        <li>Create a <code>Student</code> class with <code>final String name;</code> and <code>final int studentId;</code.</li>
                        <li>Add a <code>const</code> constructor for <code>Student</code.</li>
                        <li>Add a named constructor <code>Student.guest()</code> creating a student with name "Guest Student" and ID 0.</li>
                        <li>In main, create instances using both constructors.</li>
                    </ol>
                </div>`
          },
          {
            id: "encapsulation-m6",
            title: "6.4 Dart Encapsulation",
            content: `
                <p>Encapsulation means bundling data (attributes) and methods operating on that data within a class. It involves controlling access to an object's internal state, often by making fields private and providing public methods (getters and setters).</p>
                <p>In Dart, privacy is at the library level, not class level. An identifier is private if it starts with an underscore (<code>_</code>). Private members are only accessible within the same Dart library (same <code>.dart</code> file or files part of the same library using <code>part</code> and <code>part of</code.</p>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>// In a file, say bank_account.dart 
class BankAccount {
  String ownerName;
  double _balance; // Private field 

  BankAccount(this.ownerName, double initialBalance)
      : _balance = initialBalance >= 0 ? initialBalance : 0;

  // Public getter to access the balance 
  double get balance => _balance;

  void deposit(double amount) {
    if (amount > 0) {
      _balance += amount;
      print('Deposited \\\$amount. New balance: \\$\$_balance');
    } else {
      print('Deposit amount must be positive.');
    }
  } // 

  bool withdraw(double amount) {
    if (amount <= 0) {
      print('Withdrawal amount must be positive.');
      return false; // 
    }
    if (amount <= _balance) { // 
      _balance -= amount;
      print('Withdrew \\\$amount. New balance: \\$\$_balance');
      return true;
    } else {
      print('Insufficient funds to withdraw \\\$amount. Current balance: \\$\$_balance'); // 
      return false;
    }
  }
  void displayAccountInfo() => print('Account Owner: \$ownerName, Balance: \\$\$_balance'); // 
}

// In the same file or library:
void main() {
  var myAcc = BankAccount('Alice Wonderland', 1000.0);
  myAcc.displayAccountInfo(); // 
  print('Current balance via getter: \\$\${myAcc.balance}'); // 
  // myAcc._balance = 1000000; // Error if in different library & bypasses logic 
}</code></pre>
                </div>
                <h4>Benefits of Encapsulation:</h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong>Data Hiding:</strong> Protects internal state.</li>
                    <li><strong>Control:</strong> Class controls data access/modification.</li>
                    <li><strong>Flexibility:</strong> Internal implementation can change without affecting users of the class.</li>
                    <li><strong>Maintainability:</strong> Easier to manage code.</li>
                </ul>
                <div class="real-life-example">
                    <h4>Real-life Example:</h4>
                    <p>A TV remote is the public interface; you don't touch internal circuits (private data).</p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <ol class="list-decimal list-inside space-y-1">
                        <li>Create <code>Temperature</code> class with a private field <code>_celsius</code> (double.</li>
                        <li>Constructor <code>Temperature.celsius(double c)</code> to set <code>_celsius</code.</li>
                        <li>Public getter <code>double get celsius => _celsius;</code.</li>
                        <li>Public getter <code>double get fahrenheit => (_celsius * 9 / 5) + 32;</code.</li>
                        <li>Public setter <code>set celsius(double newCelsius)</code> that updates <code>_celsius</code.</li>
                        <li>Test in <code>main</code>.</li>
                    </ol>
                </div>`
          },
          {
            id: "getters-setters-m6",
            title: "6.5 Getters and Setters",
            content: `
                <p>Getters and setters are special methods providing read (<code>get</code>) and write (<code>set</code>) access to an object's properties (fields), allowing controlled access and modification.</p>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong>Getter:</strong> Retrieves property value. Keyword <code>get</code.</li>
                    <li><strong>Setter:</strong> Sets property value. Keyword <code>set</code.</li>
                </ul>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>class RectangleShape {
  double _width;  // Private field
  double _height; // Private field 

  RectangleShape(double w, double h)
      : _width = w > 0 ? w : 1.0, // Ensure positive width 
        _height = h > 0 ? h : 1.0; // Ensure positive height 

  // Getter for width
  double get width {
    print('Getter for width called.'); // 
    return _width;
  }

  // Setter for width
  set width(double newWidth) {
    print('Setter for width called with \$newWidth.');
    if (newWidth > 0) { // 
      _width = newWidth;
    } else {
      print('Error: Width must be positive.'); ]
    }
  }

  double get height => _height; // Getter for height (shorthand) 
  set height(double newHeight) => _height = newHeight > 0 ? newHeight : _height; // Setter for height (shorthand) 

  double get area => _width * _height; // Getter for area (computed property) 
  // A setter for area doesn't make sense logically for this class. 

  void display() => print('Rectangle: Width = \$_width, Height = \$_height, Area = \$area'); // 
}

void main() {
  var rect = RectangleShape(10, 5);
  print('Current width: \${rect.width}'); // Calls 'get width' 
  rect.width = 12; // Calls 'set width' 
  rect.width = -5; // Prints error, width not changed 
  rect.display();
}</code></pre>
                </div>
                <p>A getter-only property is read-only from outside. A setter-only property (rare) is write
                <div class="real-life-example">
                    <h4>Real-life Example:</h4>
                    <p>Thermostat: <code>get temperature</code> reads current temp; <code>set temperature(newTemp)</code> adjusts heating/cooling.</p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <ol class="list-decimal list-inside space-y-1">
                        <li>Revisit <code>Student</code> class. Make <code>studentId</code> private (<code>_studentId</code.</li>
                        <li>Provide a public getter <code>int get studentId => _studentId;</code.</li>
                        <li>Do not provide a setter for <code>studentId</code> to make it unchangeable after creation.</li>
                        <li><code>name</code> can remain public or be made private with public getter/setter.</li>
                    </ol>
                </div>`
          },
          {
            id: "inheritance-m6",
            title: "6.6 Dart Inheritance",
            content: `
                <p>Inheritance allows a new class (subclass/derived class) to acquire properties and methods from an existing class (superclass/base class) using the <code>extends</code> keyword. It promotes code reuse and creates class hierarchies.</p>
                <p>A subclass inherits all non-private members of its superclass. Constructors are NOT inherited, but a subclass constructor must call a superclass constructor.</p>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>// Superclass (Base Class)
class Animal {
  String name;
  int age;
  Animal(this.name, this.age); // 

  void eat() => print('\$name is eating.');
  void makeSound() => print('\$name makes a generic sound.'); // 
}

// Subclass (Derived Class)
class Dog extends Animal {
  String breed;
  Dog(String name, int age, this.breed) : super(name, age); // Calls Animal constructor 

  void fetch() => print('\$name is fetching.'); // 

  @override // Good practice annotation 
  void makeSound() => print('\$name barks: Woof woof!'); // 
}

class Cat extends Animal {
  bool isLazy;
  Cat(String name, int age, this.isLazy) : super(name, age); // 
  @override void makeSound() => print('\$name meows: Meow!'); // 
  void purr() => print('\$name is purring.');
}

void main() {
  var myDog = Dog('Buddy', 3, 'Golden Retriever');
  myDog.eat();        // Inherited 
  myDog.makeSound();  // Overridden 
  myDog.fetch();      // Specific to Dog 

  var myCat = Cat('Whiskers', 2, true);
  myCat.makeSound();  // Overridden 
}</code></pre>
                </div>
                <p>The <code>@override</code> annotation indicates that the method is intended to override a superclass method, helping catch errors if the superclass method signature changes.</p>
                <div class="real-life-example">
                    <h4>Real-life Example:</h4>
                    <p>Superclass <code>Vehicle</code> (speed, color; start(), stop()). Subclasses <code>Car extends Vehicle</code> (adds numberOfDoors), <code>Bicycle extends Vehicle</code>. Both can override <code>start()</code> specifically.</p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <ol class="list-decimal list-inside space-y-1">
                        <li>Create superclass <code>Shape</code> with method <code>double calculateArea()</code> (returns 0.0 initially.</li>
                        <li>Subclasses <code>Circle</code> (radius) and <code>Rectangle</code> (width, height) extend <code>Shape</code>.</li>
                        <li>Implement constructors for <code>Circle</code> and <code>Rectangle</code.</li>
                        <li>Override <code>calculateArea()</code> in both (Circle: $\pi \cdot radius^2$, Rectangle: $width \cdot height$). Use <code>dart:math</code>'s <code>pi</code.</li>
                        <li>In <code>main</code>, create objects and print areas.</li>
                    </ol>
                </div>`
          },
          {
            id: "inheritance-constructors-m6",
            title: "6.7 Inheritance and Constructors",
            content: `
                <p>Constructors are not inherited. A subclass constructor must call a constructor of its direct superclass. This call happens before the subclass constructor's body executes.</p>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li>Use <code>super(...)</code> to call a superclass constructor. It must be the first thing in the subclass constructor's initializer list or body (if no initializer list.</li>
                    <li>If the superclass has a no-argument default constructor, and the subclass constructor doesn't explicitly call one, the default super constructor is called automatically.</li>
                    <li>If the superclass does not have a no-argument constructor, the subclass must explicitly call one of the superclass's constructors using <code>super</code.</li>
                </ul>
                <p><strong>Example with named super constructor:</strong> </p>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>class Vehicle {
  String model;
  int year;
  Vehicle(this.model, this.year) { print('Vehicle constructor: \$model, \$year'); }
  Vehicle.unspecified() : model = 'Unknown', year = 0 { print('Vehicle.unspecified constructor'); } // 
}

class Car extends Vehicle {
  int numberOfDoors;

  // Calling the default super constructor
  Car(String model, int year, this.numberOfDoors) : super(model, year) { // 
    print('Car constructor: \$numberOfDoors doors');
  }

  // Calling a named super constructor
  Car.electric(String model, this.numberOfDoors) : super.unspecified() { // 
    this.model = model; // Overwrites model set by super.unspecified() 
    this.year = DateTime.now().year; // Overwrites year set by super.unspecified() 
    print('Electric Car constructor: \$model, \$numberOfDoors doors, Year: \$year');
  }
  // Car.fromBlueprint(...) : super(model, year) { ... } 
}</code></pre>
                </div>
                <p><strong>Order of Execution during Instantiation:</strong> 1. Superclass constructor's initializer list. 2. Superclass constructor's body. 3. Subclass constructor's initializer list. 4. Subclass constructor's body.</p>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <ol class="list-decimal list-inside space-y-1">
                        <li>Add a <code>String color</code> property to <code>Shape</code> class, initialize in constructor.</li>
                        <li>Update <code>Circle</code>/<code>Rectangle</code> constructors to accept color, pass to <code>Shape</code> super constructor.</li>
                        <li>In <code>main</code>, create a red circle and blue rectangle.</li>
                    </ol>
                </div>`
          },
          {
            id: "module6-practice",
            title: "Module 6: Practice Questions Summary",
            isPractice: true,
            content: `
                <p>This concludes OOP Part 1. Please review these concepts thoroughly.</p>
                <ol class="list-decimal list-inside space-y-2 mt-4">
                    <li><strong>Custom Class:</strong> Design a <code>Laptop</code> class with properties (brand, model, ramInGB, hasSSD) and methods (<code>displaySpecs()</code>, <code>upgradeRam(int additionalRam)</code>). Include a constructor.</li>
                    <li><strong>Named Constructors:</strong> Add a named constructor <code>Laptop.gaming(String brand, String model)</code> to your Laptop class that sets default high RAM and SSD status.</li>
                    <li><strong>Encapsulation Challenge:</strong> Create a <code>UserProfile</code> class with a private <code>_email</code> field. Provide a public getter for email and a setter that validates the email format (simple check for '@' symbol) before updating.</li>
                    <li><strong>Vehicle Inheritance:</strong> Create a base class <code>Vehicle</code> with a <code>startEngine()</code> method. Create <code>Car</code> and <code>Motorcycle</code> subclasses that override <code>startEngine()</code> to print specific messages (e.g., "Car engine rumbles...", "Motorcycle engine roars..."). Ensure constructors call <code>super()</code>.</li>
                </ol>`
          }
        ]
      },
      module7: { // Corresponds to PDF Module 7
        title: "Module 7: Master on Object-Oriented Programming (Part 2)",
        introduction: "This module continues our exploration of Object-Oriented Programming in Dart, focusing on the <code>super</code> keyword, polymorphism, <code>static</code> members, enums, abstract classes, interfaces, and mixins. ",
        sections: [
          {
            id: "super-keyword-m7",
            title: "7.1 super Keyword",
            content: `
                <p>The <code>super</code> keyword is used in a subclass to refer to its immediate superclass.  It has two main uses: </p>
                <ol class="list-decimal list-inside my-2 ml-4">
                    <li><strong>Calling Superclass Constructors:</strong> As seen in Module 6.7, <code>super(...)</code> is used in the subclass constructor's initializer list to call a constructor of the superclass.  This is essential for initializing the inherited part of the object. </li>
                    <li><strong>Calling Superclass Methods/Accessing Properties:</strong> If a subclass overrides a method or a property (getter/setter) from its superclass, you can use <code>super.methodName()</code> or <code>super.propertyName</code> to explicitly call the superclass's version.  This is useful when you want to extend the superclass's behavior rather than completely replacing it. </li>
                </ol>
                <h4>Example: Calling Superclass Methods</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>class Beverage {
  String name;
  Beverage(this.name); // 

  void describe() {
    print('This is a beverage called \$name.'); // 
  }

  String getIngredients() {
    return 'Water'; // 
  }
}

class Coffee extends Beverage {
  String beanType;
  Coffee(String name, this.beanType) : super(name); // 

  @override
  void describe() {
    super.describe(); // Call Beverage's describe() method 
    print('It is a type of coffee made with \$beanType beans.'); // 
  }

  @override
  String getIngredients() {
    // Extend the superclass's ingredients
    return '\${super.getIngredients()}, Coffee Beans (\$beanType)'; // 
  }

  void brew() {
    print('Brewing \$name coffee...'); // 
  }
}

class Tea extends Beverage {
  String teaType; // e.g., Green, Black
  Tea(String name, this.teaType) : super(name); // 

  @override
  void describe() {
    super.describe(); // Call Beverage's describe() 
    print('It is a \$teaType tea.'); // 
  }

   @override
  String getIngredients() {
    return '\${super.getIngredients()}, Tea Leaves (\$teaType)'; // 
  }

  void steep() {
    print('Steeping \$name (\$teaType)...'); // 
  }
}

void main() {
  var myCoffee = Coffee('Espresso', 'Arabica');
  myCoffee.describe();
  // Output:
  // This is a beverage called Espresso. 
  // It is a type of coffee made with Arabica beans. 
  print('Ingredients for \${myCoffee.name}: \${myCoffee.getIngredients()}'); // 
  // Output: Ingredients for Espresso: Water, Coffee Beans (Arabica) 
  myCoffee.brew();

  print('\\n--- Tea ---');
  var myTea = Tea('Earl Grey', 'Black'); // 
  myTea.describe();
  print('Ingredients for \${myTea.name}: \${myTea.getIngredients()}');
  myTea.steep();
}</code></pre>
                </div>
                <p>In this example, <code>Coffee</code>'s <code>describe()</code> method first calls <code>super.describe()</code> to execute the <code>describe()</code> method from the <code>Beverage</code> class, and then adds its own specific description.  Similarly for <code>getIngredients()</code>. </p>
                <div class="real-life-example">
                    <h4>Real-life Example:</h4>
                    <p>Imagine a <code>Chef</code> class with a <code>cookMeal()</code> method. A <code>PastryChef</code> class extends <code>Chef</code>. When <code>PastryChef.cookMeal()</code> is called for a dessert, it might first call <code>super.cookMeal()</code> to do some general preparation defined in <code>Chef</code>, and then add its specific pastry-making steps. </p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <ol class="list-decimal list-inside space-y-1">
                        <li>Create a class <code>Logger</code> with a method <code>void log(String message)</code> that prints "[LOG]: message". </li>
                        <li>Create a subclass <code>TimestampedLogger</code> that extends <code>Logger</code>. </li>
                        <li>Override the <code>log</code> method in <code>TimestampedLogger</code>. This overridden method should first print the current timestamp (e.g., <code>DateTime.now().toString()</code>) and then call the superclass's <code>log</code> method to print the actual message with the "[LOG]" prefix. </li>
                        <li>Test it by creating an instance of <code>TimestampedLogger</code> and calling its <code>log</code> method. </li>
                    </ol>
                </div>`
          },
          {
            id: "polymorphism-m7",
            title: "7.2 Dart Polymorphism",
            content: `
                <p>Polymorphism, meaning "many forms," is a core OOP concept that allows objects of different classes to be treated as objects of a common superclass.  The specific behavior that occurs when a method is called on an object depends on the actual type of the object at runtime. </p>
                <p>This is typically achieved through: </p>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong>Method Overriding:</strong> Subclasses provide a specific implementation for a method that is already defined in its superclass. </li>
                    <li><strong>Using Superclass Type References:</strong> You can declare a variable of a superclass type and assign an object of any of its subclasses to it.  When you call a method on this variable, Dart determines at runtime which version of the method to execute. </li>
                </ul>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>abstract class Shape { // Using an abstract class 
  String color;
  Shape(this.color);

  void draw(); // Abstract method - no implementation here 
  double calculateArea(); // Abstract method 
}

class Circle extends Shape {
  double radius;
  Circle(String color, this.radius) : super(color); // 

  @override
  void draw() {
    print('Drawing a \$color circle with radius \$radius.'); // 
  }

  @override
  double calculateArea() {
    return 3.14159 * radius * radius; // 
  }
}

class Rectangle extends Shape {
  double width;
  double height;
  Rectangle(String color, this.width, this.height) : super(color); // 

  @override
  void draw() {
    print('Drawing a \$color rectangle with width \$width and height \$height.'); // 
  }

  @override
  double calculateArea() {
    return width * height; // 
  }
}

class Triangle extends Shape {
  double base;
  double height;
  Triangle(String color, this.base, this.height) : super(color); // 

  @override
  void draw() {
    print('Drawing a \$color triangle with base \$base and height \$height.'); // 
  }
  @override 
  double calculateArea() { // 
    return 0.5 * base * height;
  }
}

// A function that works with any Shape object
void printShapeDetails(Shape shape) {
  print('\\n--- Shape Details ---');
  shape.draw(); // Calls the specific draw() method of the actual object type 
  print('Area: \${shape.calculateArea()}'); // Calls the specific calculateArea() 
}


void main() {
  Shape myCircle = Circle('Red', 5.0);
  Shape myRectangle = Rectangle('Blue', 4.0, 6.0);
  Shape myTriangle = Triangle('Green', 3.0, 4.0); // 

  myCircle.draw(); // Calls Circle's draw() 
  print('Circle Area: \${myCircle.calculateArea()}');

  myRectangle.draw(); // Calls Rectangle's draw()
  print('Rectangle Area: \${myRectangle.calculateArea()}');

  myTriangle.draw(); // Calls Triangle's draw() 
  print('Triangle Area: \${myTriangle.calculateArea()}');

  print('\\n--- Using a polymorphic list ---'); // 
  List<Shape> shapes = [
    Circle('Yellow', 3.0),
    Rectangle('Purple', 2.0, 5.0),
    Triangle('Orange', 6.0, 2.5)
  ]; // 

  for (Shape shape in shapes) { // 
    printShapeDetails(shape); // 
  }
}</code></pre>
                </div>
                <p>In the <code>printShapeDetails</code> function and the loop, <code>shape.draw()</code> and <code>shape.calculateArea()</code> exhibit polymorphism.  The exact method executed depends on whether <code>shape</code> is currently a <code>Circle</code>, <code>Rectangle</code>, or <code>Triangle</code>. </p>
                <h4>Benefits of Polymorphism:</h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong>Flexibility and Extensibility:</strong> You can add new subclasses of <code>Shape</code> (e.g., <code>Square</code>) without changing the <code>printShapeDetails</code> function. </li>
                    <li><strong>Simpler Code:</strong> You can write generic code that works with objects of different but related types. </li>
                </ul>
                <div class="real-life-example">
                    <h4>Real-life Example:</h4>
                    <p>A remote control (<code>RemoteControl</code> superclass) with a <code>pressPowerButton()</code> method. Different devices (<code>TV</code>, <code>DVDPlayer</code> subclasses) respond to this method in their own specific way.  The remote doesn't need to know the exact device type. </p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <ol class="list-decimal list-inside space-y-1">
                        <li>Create a superclass <code>Employee</code> with a method <code>double calculateSalary()</code>. </li>
                        <li>Create two subclasses: <code>Manager</code> (with <code>baseSalary</code> and <code>bonus</code>) and <code>Developer</code> (with <code>hourlyRate</code> and <code>hoursWorked</code>). </li>
                        <li>Override <code>calculateSalary()</code> in both subclasses. </li>
                        <li>Create a list of <code>Employee</code> objects containing both <code>Manager</code> and <code>Developer</code> instances. </li>
                        <li>Iterate through the list and print the salary for each employee, demonstrating polymorphism. </li>
                    </ol>
                </div>`
          },
          {
            id: "static-keyword-m7",
            title: "7.3 static Keyword",
            content: `
                <p>The <code>static</code> keyword is used to define members (fields or methods) that belong to the class itself, rather than to instances of the class.  This means you can access static members directly using the class name, without creating an object. </p>
                <h4>Static Fields (Class Variables):</h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li>Shared among all instances of the class.  There's only one copy of a static field. </li>
                    <li>Useful for constants or properties common to all instances. </li>
                </ul>
                <h4>Static Methods (Class Methods):</h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li>Can be called directly on the class. </li>
                    <li>Cannot access instance members (non-static fields or methods) directly because they don't operate on a specific instance (no <code>this</code>).  They can access other static members. </li>
                    <li>Often used as utility functions or for operations not requiring instance state. </li>
                </ul>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>class MathUtils {
  static const double PI = 3.1415926535; // Static field (constant) 
  static int operationCount = 0; // Static variable to count operations 

  static double circleArea(double radius) { // Static method 
    operationCount++;
    return PI * radius * radius; // 
  }
  static int add(int a, int b) {
    operationCount++;
    return a + b; // 
  }
  // void instanceMethodExample() { print(PI); } // Can access static members 
}

class AppConfig {
    static final String appName = "My Awesome App"; // 
    static final String version = "1.0.2"; // 
    static bool _isInitialized = false; // 

    static void initialize() { // 
        if (!_isInitialized) {
            print("\$appName v\$version is initializing..."); // 
            _isInitialized = true; // 
            print("Initialization complete."); // 
        } else {
            print("\$appName is already initialized."); // 
        }
    }
}

void main() {
  print('Value of PI: \${MathUtils.PI}'); // 
  double area1 = MathUtils.circleArea(5.0); // 
  print('Area of circle with radius 5: \$area1');
  int sum1 = MathUtils.add(10, 20); // 
  print('Sum of 10 and 20: \$sum1');
  double area2 = MathUtils.circleArea(2.0); // 
  print('Total MathUtils operations: \${MathUtils.operationCount}'); // Output: 3 
  
  print('\\n--- AppConfig ---');
  AppConfig.initialize(); // First time 
  AppConfig.initialize(); // Second time 
  print('App Name: \${AppConfig.appName}'); // 
}</code></pre>
                </div>
                <h4>When to use static members:</h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li>For utility methods that don't depend on object state (e.g., math functions). </li>
                    <li>For class-relevant constants (e.g., <code>Math.PI</code>). </li>
                    <li>To manage state shared across all instances (e.g., object creation counter). </li>
                    <li>For implementing singleton patterns. </li>
                </ul>
                <div class="real-life-example">
                    <h4>Real-life Example:</h4>
                    <p><strong>Static Field:</strong> <code>CarBlueprint.numberOfWheels = 4</code>. </p>
                    <p><strong>Static Method:</strong> <code>CurrencyConverter.convertToUSD(amount, fromCurrency)</code>. </p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <ol class="list-decimal list-inside space-y-1">
                        <li>Create class <code>StringUtils</code>. </li>
                        <li>Add static method <code>bool isPalindrome(String text)</code>. </li>
                        <li>Add static field <code>int checkCount = 0;</code> that increments when <code>isPalindrome</code> is called. </li>
                        <li>Test in <code>main</code> and print <code>checkCount</code>. </li>
                    </ol>
                </div>`
          },
          {
            id: "enums-m7",
            title: "7.4 Dart enum",
            content: `
                <p>Enums (enumerations) are a special kind of class used to represent a fixed number of constant values.  They provide a type-safe way to define a set of named instances. </p>
                <h4>Defining an Enum: </h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>enum DayOfWeek { 
  monday, tuesday, wednesday, thursday, friday, saturday, sunday 
} // 

enum Status { 
  pending, running, completed, failed 
} // 

// Enums can also have methods and fields (enhanced enums since Dart 2.17)
enum TrafficLight {
  red(durationSeconds: 60),
  yellow(durationSeconds: 5),
  green(durationSeconds: 45);

  final int durationSeconds; // Field for each enum value 
  const TrafficLight({required this.durationSeconds}); // Constructor for enum values 

  String get message { // 
    switch (this) {
      case TrafficLight.red: return 'Stop!';
      case TrafficLight.yellow: return 'Caution!';
      case TrafficLight.green: return 'Go!';
    }
  }
}</code></pre>
                </div>
                <h4>Using an Enum: </h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>void main() {
  DayOfWeek today = DayOfWeek.friday;
  if (today == DayOfWeek.saturday || today == DayOfWeek.sunday) {
    print("It's the weekend!"); // 
  } else {
    print("It's a weekday.");
  }

  print('Index of \$today: \${today.index}'); // Output: 4 (if friday is 5th) 
  print('All days: \${DayOfWeek.values}'); // 

  Status currentStatus = Status.running; // 
  switch (currentStatus) {
    case Status.pending: print('Task is waiting.'); break; // 
    case Status.running: print('Task in progress.'); break;
    // ... other cases ...
    // No default needed if all enum values are covered. 
  }

  print('\\n--- Traffic Light Enum with methods/fields ---'); // 
  TrafficLight currentLight = TrafficLight.red;
  print('Current light: \$currentLight'); // 
  print('Message: \${currentLight.message}'); // 
  print('Duration: \${currentLight.durationSeconds} seconds'); // 

  for (var light in TrafficLight.values) {
    print('\${light.name}: lasts \${light.durationSeconds}s, message: "\${light.message}"'); // 
  }
}</code></pre>
                </div>
                <h4>Benefits of Enums:</h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong>Type Safety:</strong> Prevents arbitrary string/integer values. </li>
                    <li><strong>Readability:</strong> Clearer than "magic numbers" or strings. </li>
                    <li><strong>Maintainability:</strong> Changes localized to enum definition. </li>
                    <li><strong>Good with <code>switch</code> statements:</strong> Analyzer ensures all cases covered. </li>
                </ul>
                <div class="real-life-example">
                    <h4>Real-life Example:</h4>
                    <p>States of a traffic light (Red, Yellow, Green), days of the week, T-shirt sizes.</p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <ol class="list-decimal list-inside space-y-1">
                        <li>Define enum <code>PaymentMethod</code> (creditCard, paypal, bankTransfer, cashOnDelivery). </li>
                        <li>Function <code>processPayment(double amount, PaymentMethod method)</code> uses switch to print messages. </li>
                        <li>Call <code>processPayment</code> with different methods. </li>
                    </ol>
                </div>`
          },
          {
            id: "abstract-class-interface-m7",
            title: "7.5 Dart Abstract Class and Interface",
            content: `
                <h4>Abstract Class</h4>
                <p>Cannot be instantiated directly (<code>abstract class ClassName</code>).  Designed as a blueprint for subclasses.  Can have abstract methods (no body, declared with semicolon; subclasses must implement)  and concrete methods, constructors, fields. </p>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>abstract class AnimalSound {
  String name;
  AnimalSound(this.name); // 
  void makeSound(); // Abstract method 
  void sleep() => print('\$name is sleeping.'); // Concrete method 
}
class Lion extends AnimalSound {
  Lion(String name) : super(name);
  @override void makeSound() => print('\$name roars: Rooooar!'); // 
}
class Bird extends AnimalSound {
  Bird(String name) : super(name);
  @override void makeSound() => print('\$name chirps: Tweet tweet!'); // 
  void fly() => print('\$name is flying.'); // 
}
void main() {
  // AnimalSound myAnimal = AnimalSound('Generic'); // ERROR 
  Lion simba = Lion('Simba'); simba.makeSound(); simba.sleep(); // 
  Bird tweety = Bird('Tweety'); tweety.makeSound(); tweety.fly(); // 
  List<AnimalSound> zooAnimals = [simba, tweety]; // 
  for (var animal in zooAnimals) animal.makeSound(); // 
}</code></pre>
                </div>
                <h4>Interface (Implicit Interfaces in Dart)</h4>
                <p>Dart doesn't have a dedicated <code>interface</code> keyword.  Every class implicitly defines an interface.  An interface defines a contract (methods/fields a class must have if it <code>implements</code> that interface).  A class can implement multiple interfaces and must provide concrete implementations for all members of the interface(s) unless the implementing class is itself abstract.  This achieves a form of multiple inheritance of type, not implementation. </p>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>class Printer { // Implicitly defines Printer interface 
  void printDocument(String documentName) { print('Printing: \$documentName via Printer class'); } // 
  String getStatus() => 'Printer ready'; // 
}
class Scanner { void scanDocument(String documentName) => print('Scanning: \$documentName'); } // 

class MultifunctionPrinter implements Printer, Scanner { // Implements two interfaces 
  String deviceName;
  MultifunctionPrinter(this.deviceName);
  @override void printDocument(String documentName) => print('\$deviceName printing: \$documentName'); // 
  @override String getStatus() => '\$deviceName is ready.'; // 
  @override void scanDocument(String documentName) => print('\$deviceName scanning: \$documentName'); // 
  void sendFax(String doc, String to) => print('\$deviceName faxing \$doc to \$to.'); // 
}
class SimpleLaserPrinter implements Printer { // 
    @override void printDocument(String documentName) => print('Laser printing: \$documentName');
    @override String getStatus() => 'Laser printer idle.';
}

void main() {
  MultifunctionPrinter mfp = MultifunctionPrinter('OfficeJet Pro');
  mfp.printDocument('Report.docx'); mfp.scanDocument('Invoice.pdf'); // 
  
  Printer laserPrinter = SimpleLaserPrinter(); // Using interface type 
  laserPrinter.printDocument('Presentation.ppt');
  // laserPrinter.scanDocument(); // Error: Printer interface doesn't have scanDocument 
}</code></pre>
                </div>
                <p>When you <code>implement</code> an interface, you don't inherit implementations (method bodies), only signatures and field declarations, which you must then implement.  This differs from <code>extends</code>. </p>
                <h4>When to use Abstract Classes vs. Interfaces:</h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong>Abstract Class (<code>extends</code>):</strong> For "is-a" relationships (<code>Dog</code> is an <code>Animal</code>).  Share common implemented functionality and define a common structure.  Can only extend one. </li>
                    <li><strong>Interface (<code>implements</code>):</strong> For "can-do" relationships (<code>Bird</code> can <code>Flyable</code>).  Defines a contract for capabilities.  Can implement multiple. </li>
                </ul>
                <div class="real-life-example">
                    <h4>Real-life Examples:</h4>
                    <p><strong>Abstract Class:</strong> <code>VehicleBlueprint</code> with abstract <code>startEngine()</code> and concrete <code>honkHorn()</code>. </p>
                    <p><strong>Interface:</strong> <code>Serializable</code> with <code>toJson()</code>. <code>User</code>, <code>Product</code> can implement it. </p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <ol class="list-decimal list-inside space-y-1">
                        <li>Define abstract class <code>DatabaseService</code> with abstract methods <code>Future&lt;void&gt; saveData(String data)</code> and <code>Future&lt;String&gt; fetchData(String id)</code>. </li>
                        <li>Create <code>FirebaseService</code> and <code>LocalDbService</code> implementing <code>DatabaseService</code>. </li>
                        <li>In <code>main</code>, test polymorphism with <code>DatabaseService</code> type. </li>
                    </ol>
                </div>`
          },
          {
            id: "mixins-m7",
            title: "7.6 Dart mixin",
            content: `
                <p>Mixins offer a way to reuse a class's code in multiple class hierarchies without traditional inheritance.  They allow "mixing in" capabilities (methods and fields) into other classes.  Solves sharing behavior between unrelated classes or when a class already extends another. </p>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li>A class can use multiple mixins. </li>
                    <li>Defined using <code>mixin</code> keyword.  Used with <code>with</code> keyword. </li>
                </ul>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>mixin Flyer { // Mixin definition 
  void fly() => print("\${_getCreatureName()} is flying!"); // 
  // Mixins cannot declare constructors. 
  // Can declare instance variables, methods, and abstract methods. 
  String _getCreatureName(); // Abstract method to be implemented by user 
}
mixin Swimmer {
  void swim() => print("\${_getCreatureName()} is swimming!"); // 
  String _getCreatureName(); // 
}

class AnimalForMixin { String name; AnimalForMixin(this.name); } // 

class Bird extends AnimalForMixin with Flyer { // 
  Bird(String name) : super(name);
  @override String _getCreatureName() => name; // Implementing abstract method 
}
class Fish extends AnimalForMixin with Swimmer { // 
  Fish(String name) : super(name);
  @override String _getCreatureName() => name;
}
class Duck extends AnimalForMixin with Flyer, Swimmer { // Uses both mixins 
  Duck(String name) : super(name);
  @override String _getCreatureName() => name;
  @override void fly() => print('\$name the duck is flapping majestically!'); 
}

// Restrict mixin usage with 'on'
mixin ElectricPowered on Vehicle { // Can only be used with classes extending Vehicle 
  void charge() => print('\$model is charging.'); // Can access Vehicle members 
  // String model; // This line would cause an error, model is from Vehicle
}
class Vehicle { String model; Vehicle(this.model); } // 
class ElectricCar extends Vehicle with ElectricPowered { ElectricCar(String model) : super(model); } // 

void main() {
  var sparrow = Bird('Sparrow'); sparrow.fly(); // 
  var nemo = Fish('Nemo'); nemo.swim(); // 
  var donald = Duck('Donald'); donald.fly(); donald.swim(); // 
  var tesla = ElectricCar('Tesla Model S'); tesla.charge(); // 
}</code></pre>
                </div>
                <h4>Key characteristics of Mixins:</h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong>No Constructors:</strong> Mixins cannot declare constructors. </li>
                    <li><strong><code>on</code> Clause:</strong> Restricts mixin usage to subtypes of a specific supertype, allowing safe access to supertype members. </li>
                    <li><strong>Linearization:</strong> If multiple mixins (or class and mixins) define methods with the same name, Dart resolves which method is called based on a specific order (rightmost mixin in <code>with</code> clause or class itself takes precedence).</li>
                </ul>
                <div class="real-life-example">
                    <h4>Real-life Example:</h4>
                    <p>Employees (Manager, Developer, Salesperson). <code>Manager</code> and <code>Developer</code> might need <code>ProjectManagement</code> skills (mixin).  <code>Salesperson</code> and some <code>Manager</code>s might need <code>ClientNegotiation</code> skills (mixin).  Mixins add these without complex inheritance. </p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <ol class="list-decimal list-inside space-y-1">
                        <li>Create mixin <code>LoggerMixin</code> with method <code>void log(String message)</code> printing "[MIXIN-LOG]: message". </li>
                        <li>Create class <code>User</code> (name property) and <code>Product</code</li>
                        <li>Have both <code>User</code> and <code>Product</code> use <code>LoggerMixin</code>. </li>
                        <li>In <code>main</code>, test <code>log</code> method on instances. </li>
                    </ol>
                </div>`
          },
          {
            id: "module7-practice-summary",
            title: "Module 7: Practice Questions Summary",
            isPractice: true,
            content: `
                <p>This completes "Object-Oriented Programming (Part 2)".  Review exercises from sections 7.1 to 7.6. Focus on using <code>super</code> for constructors and methods, implementing polymorphism with abstract classes and method overriding, correctly using <code>static</code> members, defining and using <code>enum</code> types, understanding the difference and use cases for abstract classes vs. implicit interfaces, and applying mixins for code reuse across different class hierarchies.</p>`
          }
        ]
      },
      module8: { // Corresponds to PDF Module 8
        title: "Module 8: Advanced OOP & Design Patterns",
        introduction: "This module delves into more sophisticated OOP features in Dart and introduces common design patterns like Factory, Singleton, Builder, Prototype, and discusses Composition vs. Inheritance and SOLID principles. ",
        sections: [
          {
            id: "factory-constructors-m8",
            title: "8.1 Dart Factory Constructors",
            content: `
                <p>A <code>factory</code> constructor gives more flexibility in creating objects.  Unlike generative constructors (which always create a new instance), a factory constructor: </p>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li>Can return an instance of a subtype. </li>
                    <li>Can return an existing cached instance (e.g., for Singleton pattern). </li>
                    <li>Doesn't necessarily create a new instance every time. </li>
                    <li>Does not have access to <code>this</code>. </li>
                </ul>
                <p>Keyword: <code>factory</code>. </p>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>abstract class ShapeFactory {
  // Factory constructor 
  factory ShapeFactory(String type, {double? arg1, double? arg2}) {
    if (type == 'circle' && arg1 != null) {
      return CircleShape(arg1); // Returns an instance of a subtype 
    }
    if (type == 'rectangle' && arg1 != null && arg2 != null) {
      return RectangleShape(arg1, arg2); // Returns an instance of another subtype 
    }
    throw ArgumentError('Invalid shape type or arguments'); // 
  }
  void draw(); // 
  double calculateArea(); // 
}

class CircleShape implements ShapeFactory {
  final double radius;
  CircleShape(this.radius);
  @override void draw() => print('Drawing circle with radius \$radius'); // 
  @override double calculateArea() => 3.14159 * radius * radius; // 
}

class RectangleShape implements ShapeFactory {
  final double width, height;
  RectangleShape(this.width, this.height);
  @override void draw() => print('Drawing rectangle \$width x \$height'); // 
  @override double calculateArea() => width * height; // 
}

// Singleton example using a factory constructor 
class Logger {
  static Logger? _instance; // Cached instance 
  final String name;
  Logger._internal(this.name); // Private generative constructor 

  factory Logger(String name) { // Factory constructor for Singleton 
    _instance ??= Logger._internal(name); // 
    return _instance!; // 
  }
  void log(String message) => print('[\${this.name} Logger]: \$message'); // 
}

void main() {
  print('--- Shape Factory ---');
  ShapeFactory circle = ShapeFactory('circle', arg1: 5.0); // 
  ShapeFactory rectangle = ShapeFactory('rectangle', arg1: 4.0, arg2: 6.0); // 
  circle.draw(); print('Circle Area: \${circle.calculateArea()}'); // 
  rectangle.draw(); print('Rectangle Area: \${rectangle.calculateArea()}'); // 
  
  print('\\n--- Logger Singleton ---');
  Logger logger1 = Logger('AppSystem'); // 
  Logger logger2 = Logger('Network');   // Returns the SAME instance 
  logger1.log('System initialized.');
  logger2.log('Network request sent.'); // Will use 'AppSystem' as name 
  print('Are logger1 and logger2 the same instance? \${identical(logger1, logger2)}'); // true 
}</code></pre>
                </div>
                <div class="real-life-example">
                    <h4>Real-life Examples:</h4>
                    <p><strong>Factory:</strong> A car factory (<code>ShapeFactory</code>) producing a "sedan" (<code>CircleShape</code>) or "truck" (<code>RectangleShape</code>) based on request. </p>
                    <p><strong>Singleton Logger:</strong> A single, global logging service for an application. </p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <p>Create an abstract class <code>NotificationService</code> with <code>send(String message)</code>.  Add a factory constructor that returns <code>EmailService</code> or <code>SMSService</code> (implementing <code>NotificationService</code>) based on a string argument ('email' or 'sms'). Test it.</p>
                </div>`
          },
          {
            id: "generics-m8",
            title: "8.2 Dart Generics",
            content: `
                <p>Generics allow writing code that works with different types in a type-safe way, using type placeholders (e.g., <code>T</code>). </p>
                <h4>Why use Generics? </h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong>Type Safety:</strong> Catch type errors at compile time. </li>
                    <li><strong>Code Reusability:</strong> Write once, use with various types. </li>
                    <li><strong>Reduced Code Duplication.</strong> </li>
                </ul>
                <h4>Generic Class: </h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>class Box<T> { // T is a type parameter 
  T _item;
  Box(this._item); // 
  T getItem() => _item; // 
  void setItem(T newItem) => _item = newItem; // 
  void displayItemType() => print('Item type: \${T.toString()}'); // 
}
void main() {
  Box<int> intBox = Box<int>(123); // 
  Box<String> stringBox = Box('Hello Dart'); // Type can be inferred 
  Box<List<double>> listDoubleBox = Box([1.0, 2.5]); // 
  // Box dynamicBox = Box(true); // Defaults to Box<dynamic> 
}</code></pre>
                </div>
                <h4>Generic Function:</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>T? firstElement<T>(List<T> list) { // 
  return list.isEmpty ? null : list[0];
}
// Generic function with type constraints
// R sumOfNumbers<T extends num, R extends num>(T a, T b) { ... } // T must be num or subtype 

void main() {
  List<String> words = ['apple', 'banana'];
  print(firstElement<String>(words)); // apple 
  List<int> numbers = [10, 20];
  print(firstElement(numbers)); // Type inferred, 10 
}</code></pre>
                </div>
                <p><code>&lt;T&gt;</code>: <code>T</code> is a type parameter.  <code>T extends SomeType</code> is a type constraint, meaning <code>T</code> must be <code>SomeType</code> or its subtype. </p>
                <div class="real-life-example">
                    <h4>Real-life Example (Generics):</h4>
                    <p>A physical box (<code>Box&lt;T&gt;</code>) can hold books (<code>Box&lt;Book&gt;</code>), apples (<code>Box&lt;Apple&gt;</code>), etc. Box functionality is same, content type <code>T</code> varies. </p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <ol class="list-decimal list-inside space-y-1">
                        <li>Create generic class <code>Cache&lt;K, V&gt;</code> storing key-value pairs. </li>
                        <li>Methods: <code>void store(K key, V value)</code>, <code>V? retrieve(K key)</code>, <code>void remove(K key)</code>. </li>
                        <li>Use a <code>Map&lt;K, V&gt;</code> internally. </li>
                        <li>Test with <code>Cache&lt;String, int&gt;</code> and <code>Cache&lt;int, Product&gt;</code>. </li>
                    </ol>
                </div>`
          },
          {
            id: "singleton-pattern-m8",
            title: "8.3 Dart Singleton Pattern",
            content: `
                <p>The Singleton pattern ensures a class has only one instance and provides a global point of access to it. </p>
                <p>Implemented using: </p>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li>A private constructor. </li>
                    <li>A static field to hold the single instance. </li>
                    <li>A static method or factory constructor to get the instance. </li>
                </ul>
                <p>Example using a factory constructor (similar to Logger in 8.1) or static getter:</p>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>class AppSettings {
  static final AppSettings _instance = AppSettings._internal(); // Static private instance 
  AppSettings._internal() { // Private constructor 
    print('AppSettings instance created.');
    _theme = 'dark'; _fontSize = 14; // 
  }
  factory AppSettings() => _instance; // Public factory constructor 
  // Alternatively: static AppSettings get instance => _instance; 

  late String _theme; // 
  late int _fontSize; // 
  String get theme => _theme; // 
  set theme(String newTheme) { _theme = newTheme; print('Theme set to: \$_theme'); } // 
  int get fontSize => _fontSize; 
  set fontSize(int newSize) { if (newSize > 0) _fontSize = newSize; } // 
  void displaySettings() => print('Settings: Theme=\$_theme, FontSize=\$_fontSize'); // 
}
void main() {
  AppSettings settings1 = AppSettings(); // 
  AppSettings settings2 = AppSettings(); // Gets SAME instance 
  print('settings1 and settings2 are identical: \${identical(settings1, settings2)}'); // true 
  settings2.theme = 'light'; // 
  settings1.displaySettings(); // Shows 'light' 
}</code></pre>
                </div>
                <p><strong>Use Cases:</strong> Shared resource management (database connection), global app configuration, logging services. </p>
                <div class="note"><p><strong>Caution:</strong> Overuse can lead to tight coupling and harder testing. Consider Dependency Injection as an alternative. </p></div>
                <div class="real-life-example">
                    <h4>Real-life Example:</h4>
                    <p>A building's main power switch – only one, controls all power. </p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <p>Create <code>SessionManager</code> Singleton with <code>login(String userId)</code>, <code>logout()</code>, <code>String? currentUserId</code>. Ensure only one instance. Test. </p>
                </div>`
          },
          {
            id: "dependency-injection-m8",
            title: "8.4 Dart Dependency Injection (DI)",
            content: `
                <p>Dependency Injection (DI) is a design pattern where an object receives its dependencies (other objects it needs) from an external source rather than creating them itself.  This promotes loose coupling, modularity, testability, and maintainability. </p>
                <h4>Ways to achieve DI: </h4>
                <ol class="list-decimal list-inside my-2 ml-4">
                    <li><strong>Constructor Injection:</strong> Dependencies passed via constructor (most common). </li>
                    <li><strong>Setter Injection:</strong> Dependencies passed via public setters. </li>
                    <li><strong>Interface Injection:</strong> Class implements an interface for injecting dependencies (less common in Dart). </li>
                </ol>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>// --- Define Services (Dependencies) ---
abstract class NotificationServiceDI { void sendNotification(String userId, String message); } 
class EmailServiceDI implements NotificationServiceDI {
  @override void sendNotification(String userId, String message) => print('EMAIL to \$userId: \$message'); // 
}
class SMSServiceDI implements NotificationServiceDI {
  @override void sendNotification(String userId, String message) => print('SMS to \$userId: \$message'); // 
}

// --- Class that uses a dependency ---
class UserManager {
  final NotificationServiceDI _notificationService; // Dependency is abstract type 
  UserManager(this._notificationService); // Constructor Injection 

  void registerUser(String userId, String initialMessage) {
    print('User \$userId registered.');
    _notificationService.sendNotification(userId, 'Welcome, \$initialMessage!'); // 
  }
}
void main() {
  // --- DI in action --- 
  NotificationServiceDI emailService = EmailServiceDI(); // 
  NotificationServiceDI smsService = SMSServiceDI();

  UserManager userManagerWithEmail = UserManager(emailService); // Inject dependency 
  userManagerWithEmail.registerUser('alice@example.com', 'thanks for joining');

  UserManager userManagerWithSMS = UserManager(smsService); // 
  userManagerWithSMS.registerUser('+1234567890', 'thanks for joining');
  // Benefits: Not tied to specific implementation, easy to swap/mock, loose coupling. 
}</code></pre>
                </div>
                <h4>Benefits of DI: </h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong>Decoupling:</strong> Reduces dependencies. </li>
                    <li><strong>Testability:</strong> Easier to mock dependencies. </li>
                    <li><strong>Flexibility:</strong> Easy to swap implementations. </li>
                    <li><strong>Reusability:</strong> Components more self-contained. </li>
                </ul>
                <div class="real-life-example">
                    <h4>Real-life Example:</h4>
                    <p>A car (<code>UserManager</code>) needs an engine (<code>NotificationServiceDI</code>). Engine is built separately and "injected" during assembly. Allows different cars to use different engines.</p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <ol class="list-decimal list-inside space-y-1">
                        <li>Interface <code>PaymentProcessor</code> with <code>bool processPayment(double amount)</code>. </li>
                        <li>Implementations: <code>CreditCardProcessor</code>, <code>PayPalProcessor</code>. </li>
                        <li>Class <code>Order</code> takes <code>PaymentProcessor</code> in constructor (constructor injection). </li>
                        <li><code>Order.checkout(double totalAmount)</code> uses injected processor. </li>
                        <li>Test with different processors. </li>
                    </ol>
                </div>`
          },
          {
            id: "prototype-pattern-m8",
            title: "8.5 Dart Prototype Pattern",
            content: `
                <p>The Prototype pattern is a creational design pattern to create new objects by copying an existing object (the prototype), instead of creating from scratch via constructor.  Useful when object creation is expensive/complex. </p>
                <h4>Concept: </h4>
                <ol class="list-decimal list-inside my-2 ml-4">
                    <li>Interface/abstract class with a <code>clone()</code> method. </li>
                    <li>Concrete classes implement <code>clone()</code>. </li>
                    <li>Clients get new object by calling <code>clone()</code> on a prototype. </li>
                </ol>
                <p>Dart lacks built-in deep cloning; usually implemented manually by copying fields.</p>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>// Abstract prototype class
abstract class ShapePrototype {
  String id;
  String color;
  ShapePrototype(this.id, this.color); // 
  ShapePrototype clone(); // The clone method 
  void draw(); // 
}

// Concrete prototype: Circle
class CirclePrototype extends ShapePrototype {
  double radius;
  CirclePrototype(String id, String color, this.radius) : super(id, color);
  // Constructor for cloning 
  CirclePrototype.fromSource(CirclePrototype source)
      : radius = source.radius, super(source.id, source.color); // 
  @override
  ShapePrototype clone() => CirclePrototype.fromSource(this); // Creates new instance by copying 
  @override
  void draw() => print('Drawing Circle (ID: \$id, Color: \$color, Radius: \$radius)'); // 
}

// Concrete prototype: Rectangle (similar implementation) 
class RectanglePrototype extends ShapePrototype {
  double width, height;
  RectanglePrototype(String id, String color, this.width, this.height) : super(id, color);
  RectanglePrototype.fromSource(RectanglePrototype source) : width=source.width, height=source.height, super(source.id, source.color);
  @override ShapePrototype clone() => RectanglePrototype.fromSource(this);
  @override void draw() => print('Drawing Rectangle (ID: \$id, Color: \$color, W: \$width, H: \$height)');
}

void main() {
  CirclePrototype originalCircle = CirclePrototype('c1', 'Red', 10.0); // 
  CirclePrototype clonedCircle = originalCircle.clone() as CirclePrototype; // 
  clonedCircle.id = 'c2'; clonedCircle.color = 'Green'; // 
  originalCircle.draw(); clonedCircle.draw(); // 
  print('Identical: \${identical(originalCircle, clonedCircle)}'); // false 
}</code></pre>
                </div>
                <h4>When to use Prototype: </h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li>When object creation is resource-intensive. </li>
                    <li>To avoid proliferation of subclasses differing only in initial state. </li>
                    <li>To allow clients to create objects without knowing concrete types. </li>
                </ul>
                <div class="real-life-example">
                    <h4>Real-life Example:</h4>
                    <p>Cell division (mitosis); photocopier duplicating a document. </p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <p><code>UserProfile</code> class (username, email, bio, preferences list). Implement Prototype pattern, ensuring deep copy of preferences list. </p>
                </div>`
          },
          {
            id: "builder-pattern-m8",
            title: "8.6 Dart Builder Pattern",
            content: `
                <p>The Builder pattern is a creational pattern for constructing complex objects step by step.  It separates construction from representation, allowing the same process to create different representations.  Useful for objects with many optional parameters or multi-step initialization. </p>
                <h4>Concept: </h4>
                <ol class="list-decimal list-inside my-2 ml-4">
                    <li>Define a <code>Builder</code> class with methods for setting each part. </li>
                    <li>Builder has a <code>build()</code> method returning the constructed object. </li>
                    <li>Complex object might have a private constructor to force builder usage. </li>
                </ol>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>// Complex object 
class Computer {
  final String cpu, ram, storage; final String? graphicsCard, operatingSystem; // 
  // Private constructor forces use of builder 
  Computer._builder(ComputerBuilder builder)
      : cpu = builder._cpu, ram = builder._ram, storage = builder._storage,
        graphicsCard = builder._graphicsCard, operatingSystem = builder._operatingSystem; // 
  @override String toString() => 'CPU: \$cpu, RAM: \$ram, Storage: \$storage, GPU: \${graphicsCard ?? "Integrated"}, OS: \${operatingSystem ?? "None"}'; // 
}

// Builder class 
class ComputerBuilder {
  final String _cpu, _ram, _storage; // Required 
  String? _graphicsCard, _operatingSystem; // Optional 
  ComputerBuilder(this._cpu, this._ram, this._storage); // 

  ComputerBuilder setGraphicsCard(String card) { _graphicsCard = card; return this; } // 
  ComputerBuilder setOperatingSystem(String os) { _operatingSystem = os; return this; } // 

  Computer build() { // 
    if (_cpu.isEmpty || _ram.isEmpty || _storage.isEmpty) throw StateError('CPU, RAM, Storage required.'); // 
    return Computer._builder(this); // 
  }
}

void main() {
  Computer gamingPC = ComputerBuilder('Intel i9', '32GB', '2TB SSD')
      .setGraphicsCard('RTX 4090').setOperatingSystem('Windows 11').build(); // 
  print(gamingPC);
  Computer officePC = ComputerBuilder('Intel i5', '16GB', '512GB SSD').build(); // 
  print(officePC);
}</code></pre>
                </div>
                <h4>When to use Builder: </h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li>Constructor with too many (optional) parameters (telescoping constructor). </li>
                    <li>Object creation in multiple steps or different configurations. </li>
                    <li>Ensure object validity by centralizing construction logic. </li>
                </ul>
                <div class="real-life-example">
                    <h4>Real-life Example:</h4>
                    <p>Ordering a custom sandwich: tell sandwich artist (builder) components step by step. </p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <p><code>Pizza</code> class (size, crustType, toppings list, hasExtraCheese). Implement Builder pattern. </p>
                </div>`
          },
          {
            id: "factory-method-pattern-m8",
            title: "8.7 Dart Factory Method Pattern",
            content: `
                <p>A creational pattern providing an interface (abstract class) for creating objects in a superclass, but letting subclasses alter the type of objects created.  Defines a method for object creation, which subclasses override. </p>
                <h4>Concept: </h4>
                <ol class="list-decimal list-inside my-2 ml-4">
                    <li>Abstract <code>Creator</code> class with abstract <code>factoryMethod()</code> returning abstract <code>Product</code>. </li>
                    <li><code>Creator</code> may have core logic using the <code>Product</code>. </li>
                    <li>Concrete <code>Creator</code> subclasses override <code>factoryMethod()</code> to return concrete <code>Product</code> instances. </li>
                </ol>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>abstract class Document { void open(); void save(); void close(); } // 
class TextDocument implements Document { // 
  @override void open() => print('Opening text doc');
  @override void save() => print('Saving text doc');
  @override void close() => print('Closing text doc');
}
class SpreadsheetDocument implements Document { 
  @override void open() => print('Opening spreadsheet');
  @override void save() => print('Saving spreadsheet');
  @override void close() => print('Closing spreadsheet');
}

abstract class DocumentCreator { // 
  Document createDocument(); // Factory method 
  void newDocument() { Document doc = createDocument(); doc.open(); print('New doc op.'); } // 
  void saveDocument(Document doc) => doc.save(); // 
}
class TextDocumentCreator extends DocumentCreator {
  @override Document createDocument() { print('TextDocCreator: Creating TextDoc'); return TextDocument(); } // 
}
class SpreadsheetDocumentCreator extends DocumentCreator {
  @override Document createDocument() { print('SpreadsheetDocCreator: Creating Spreadsheet'); return SpreadsheetDocument(); }
}

void main() {
  DocumentCreator textCreator = TextDocumentCreator(); // 
  textCreator.newDocument();
  DocumentCreator spreadsheetCreator = SpreadsheetDocumentCreator(); // 
  spreadsheetCreator.newDocument();
}</code></pre>
                </div>
                <h4>Difference from simple Factory Constructor (8.1): </h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong>Factory Constructor:</strong> Single class decides subtype/cached instance. Logic within one class. </li>
                    <li><strong>Factory Method Pattern:</strong> Class hierarchy. Superclass defines interface for creation, subclasses implement it. Delegates instantiation to subclasses. </li>
                </ul>
                <h4>When to use Factory Method: </h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li>Class can't anticipate object class to create. </li>
                    <li>Class wants subclasses to specify objects it creates. </li>
                    <li>Localize creation logic for related objects. </li>
                </ul>
                <div class="real-life-example">
                    <h4>Real-life Example:</h4>
                    <p>Logistics company (<code>DocumentCreator</code>) needs to create "transport" (<code>Document</code>). Branches (<code>RoadLogisticsCreator</code>, <code>SeaLogisticsCreator</code>) decide specific transport (<code>Truck</code> or <code>Ship</code>). </p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <ol class="list-decimal list-inside space-y-1">
                        <li>Abstract <code>LoggerProduct</code> with <code>log()</code>.  Concrete <code>ConsoleLogger</code>, <code>FileLogger</code>. </li>
                        <li>Abstract <code>LoggerFactory</code> with <code>createLogger()</code> factory method. </li>
                        <li>Concrete factories override <code>createLogger()</code>.  Test them. </li>
                    </ol>
                </div>`
          },
          {
            id: "object-cloning-m8",
            title: "8.8 Dart Object Cloning (Recap)",
            content: `
                <p>This is essentially the Prototype Pattern (see 8.5).  Dart does not have built-in automatic cloning. </p>
                <h4>Recap of achieving cloning: </h4>
                <ol class="list-decimal list-inside my-2 ml-4">
                    <li>Define a <code>clone()</code> or <code>copyWith()</code> method. </li>
                    <li>Manually copy relevant fields. </li>
                    <li>Distinguish Deep vs. Shallow Copy: 
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><strong>Shallow Copy:</strong> Copies top-level fields. References to other objects are copied (shared sub-objects). </li>
                            <li><strong>Deep Copy:</strong> Recursively clones object fields for complete independence. </li>
                        </ul>
                    </li>
                    <li>Often uses a special constructor (e.g., <code>MyClass.fromSource()</code>) internally. </li>
                </ol>
                <p>The <code>copyWith</code> method is common for immutable objects, creating a new instance with some properties changed. </p>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>class UserConfig {
  final String userId, theme; final int fontSize; final List<String> notifications; // 
  const UserConfig({ required this.userId, required this.theme, required this.fontSize, required this.notifications }); // 

  UserConfig copyWith({ String? userId, String? theme, int? fontSize, List<String>? notifications }) { // 
    return UserConfig(
      userId: userId ?? this.userId, theme: theme ?? this.theme, fontSize: fontSize ?? this.fontSize,
      notifications: notifications ?? List<String>.from(this.notifications), // Deep copy for list 
    );
  }
  @override String toString() => 'UserConfig(userId: \$userId, theme: \$theme, fontSize: \$fontSize, notifications: \$notifications)'; // 
}
void main() {
  final originalConfig = UserConfig(userId: 'u123', theme: 'dark', fontSize: 14, notifications: ['email']); // 
  final themedConfig = originalConfig.copyWith(theme: 'light'); // 
  final adjustedConfig = originalConfig.copyWith(notifications: ['sms']); // 
  originalConfig.notifications.add('push'); // Modifying original's list 
  print('Original: \$originalConfig'); // Shows 'push'
  print('Themed (independent list): \$themedConfig'); // Does not show 'push' 
}</code></pre>
                </div>
                <p><strong>Implications:</strong> Cloning, especially deep copies, needs careful implementation.  <code>copyWith</code> is idiomatic for immutable objects. </p>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <p>Add <code>clone()</code> and/or <code>copyWith()</code> to your earlier <code>Book</code> class. Test it. </p>
                </div>`
          },
          {
            id: "composition-vs-inheritance-m8",
            title: "8.9 Dart Composition vs. Inheritance",
            content: `
                <p>Both are ways to reuse code and build class relationships. </p>
                <h4>Inheritance (is-a relationship): </h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li>Subclass <code>extends</code> superclass (specialized version). </li>
                    <li>Inherits interface and implementation. </li>
                    <li>Tight coupling; superclass changes can affect subclasses. </li>
                    <li>Single implementation inheritance in Dart. </li>
                </ul>
                <h4>Composition (has-a relationship): </h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li>Class contains instance(s) of other class(es) as fields. </li>
                    <li>Reuses code by delegating to contained objects. </li>
                    <li>Promotes loose coupling; interacts via public interface. </li>
                    <li>More flexible; dependencies can change at runtime. </li>
                </ul>
                <p class="important-note"><strong>OOP Principle:</strong> "Favor Composition over Inheritance." </p>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>// Inheritance Example
class Worker { String name; Worker(this.name); void work() => print('\$name working.'); } // 
class Developer extends Worker {
  Developer(String name) : super(name);
  void code() => print('\$name coding.');
  @override void work() { super.work(); code(); } // 
}
// Composition Example
class Engine { void start() => print('Engine on.'); } // 
class Car {
  String model;
  final Engine _engine; // Car 'has-a' Engine 
  Car(this.model, this._engine); // Engine injected 
  void startCar() { print('\$model starting...'); _engine.start(); } // Delegate 
}
class DataProcessor { 
    final String data; final Logger _logger; // Has-a Logger
    DataProcessor(this.data, this._logger);
    void process() { _logger.log('Processing \$data'); /* ... */ _logger.log('Finished \$data');} // 
}

void main() {
  Developer dev = Developer('Alice'); dev.work(); // 
  Car myCar = Car('Toyota', Engine()); myCar.startCar(); // 
  DataProcessor( 'Sample', Logger('PROCESSOR') ).process(); // 
}</code></pre>
                </div>
                <h4>When to choose:</h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong>Inheritance:</strong> Clear "is-a" relationship, reuse common behavior, enforce common interface. </li>
                    <li><strong>Composition:</strong> "Has-a" or "uses-a" relationship. For flexibility, easier testing, avoiding complex hierarchies. </li>
                </ul>
                <div class="real-life-example">
                    <h4>Real-life Example (Composition):</h4>
                    <p>A computer <em>has a</em> motherboard, CPU, RAM. It's <em>composed</em> of these parts. </p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <p><code>Robot</code> class (move, speak). Compare implementing with: </p>
                    <ol class="list-decimal list-inside space-y-1">
                        <li>Inheritance (try <code>MovingThing</code>, <code>SpeakingThing</code> - limitations?). </li>
                        <li>Composition (<code>MovementSystem</code>, <code>SpeechSynthesizer</code> components).</li>
                        <li>Mixins (<code>MovableMixin</code>, <code>SpeakableMixin</code>). </li>
                    </ol>
                </div>`
          },
          {
            id: "solid-principles-m8",
            title: "8.10 Dart SOLID Principles",
            content: `
                <p>SOLID: Five design principles for understandable, flexible, and maintainable software designs. </p>
                <h4>S – Single Responsibility Principle (SRP) </h4>
                <p>"A class should have only one reason to change." (One job/responsibility).  Benefits: Readability, maintainability, reduced coupling. </p>
                <p>Example (Violation): <code>Report</code> class generating, printing, and saving data. </p>
                <p>Example (Adherence): Separate <code>ReportData</code>, <code>ReportPrinter</code>, <code>ReportSaver</code> classes. </p>
                <h4>O – Open/Closed Principle (OCP)</h4>
                <p>"Software entities ... should be open for extension, but closed for modification."  Add new functionality without changing existing code, often via abstraction/polymorphism.  Benefits: Reduced bugs, maintainability, scalability. </p>
                <p>Example (Adherence): Abstract <code>PaymentMethodOCP</code>, concrete <code>CreditCardPaymentOCP</code>, <code>PayPalPaymentOCP</code>. New types (<code>BitcoinPaymentOCP</code>) added without modifying <code>OrderProcessorOCP</code>.</p>
                <h4>L – Liskov Substitution Principle (LSP)</h4>
                <p>"Subtypes must be substitutable for their base types."  Objects of superclass replaceable by subclass objects without affecting program correctness.  Subclasses shouldn't require more (stricter preconditions) or provide less (weaker postconditions).  Benefits: Well-designed hierarchies, reliable polymorphism. </p>
                <p>Example (Potential Violation): <code>Bird</code> with <code>fly()</code>. <code>Penguin</code> subclass throws error for <code>fly()</code>. </p>
                <h4>I – Interface Segregation Principle (ISP)</h4>
                <p>"Clients should not be forced to depend on interfaces they do not use."  Break "fat" interfaces into smaller, specific ones.  Benefits: Reduced coupling, flexibility, easier understanding. </p>
                <p>Example (Adherence): Separate <code>Coder</code>, <code>Tester</code>, <code>TeamManager</code> interfaces instead of one large <code>WorkerTasks</code>. </p>
                <h4>D – Dependency Inversion Principle (DIP)</h4>
                <p>"High-level modules should not depend on low-level modules. Both should depend on abstractions (e.g., interfaces)."  "Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions."  Promotes loose coupling via abstract interfaces. DI often used. </p>
                <p>Example (Adherence): <code>SwitchDIP</code> (high-level) depends on <code>SwitchableDevice</code> (abstraction), not concrete <code>LightBulbDIP</code> or <code>FanDIP</code> (low-level). </p>
                <div class="exercise-block"><h4>Exercise:</h4><p>Review a complex class. For each SOLID principle, identify potential violations and how to refactor.</p></div>`
          },
          {
            id: "mixin-vs-abstract-m8",
            title: "8.11 Dart Mixin vs. Abstract Class (Comparison)",
            content: `
                <p>Comparison table: </p>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong>Abstract Class (<code>extends</code>):</strong> "is-a" relationship. Common base for related classes.  Can have constructors.  Single extension. li>
                    <li><strong>Mixin (<code>with</code>):</strong> "can-do" / "has-capabilities-of".  Add behaviors to various classes.  No constructors.  Multiple mixins allowed.  Can use <code>on</code> for supertype constraints. li>
                </ul>
                <div class="code-block"><button class="copy-button">Copy</button><pre><code>abstract class Performer { String name; Performer(this.name); void perform(); } // 
mixin CanSing { void sing(String songTitle) => print('Singing: \$songTitle'); } // 
mixin CanPlayInstrument { String instrumentName = 'instrument'; void playInstrument() => print('Playing \$instrumentName'); } // 

class Singer extends Performer with CanSing { // 
  Singer(String name) : super(name);
  @override void perform() { print('\$name takes stage...'); sing('Song...'); } // 
}
class SingerGuitarist extends Performer with CanSing, CanPlayInstrument { // 
  SingerGuitarist(String name, String guitar) : super(name) { this.instrumentName = guitar; }
  @override void perform() { print('\$name begins!'); sing('Another Song'); playInstrument(); } // 
}</code></pre></div>
                <div class="exercise-block"><h4>Exercise:</h4><p><code>GameCharacter</code> (health, name). <code>SpellCasterMixin</code>, <code>MeleeFighterMixin</code>, <code>FlyerMixin</code>. Design <code>Wizard</code> and <code>Warrior</code> classes. </p></div>`
          },
          {
            id: "type-reflection-m8",
            title: "8.12 Dart Type Reflection",
            content: `
                <p>Ability of a program to examine/modify its structure/behavior at runtime.  Dart's full runtime reflection (<code>dart:mirrors</code>) is limited in AOT-compiled environments (Flutter release) for performance/size. </p>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><code>object.runtimeType</code>: Returns a <code>Type</code> object representing runtime type. </li>
                    <li><code>is</code> operator: Checks if object is instance of a type. </li>
                    <li><code>as</code> operator: Type casting. </li>
                </ul>
                <p>Code generation (e.g., <code>json_serializable</code>) is often used instead of runtime reflection. </p>
                <div class="code-block"><button class="copy-button">Copy</button><pre><code>void main() {
  String text = "Hello";
  print('text.runtimeType: \${text.runtimeType}'); // String 
  if (text is String) print('text is String.'); // 
  Object val = "I am a string";
  if (val is String) { String s = val as String; print(s.toUpperCase()); } // 
}</code></pre></div>
                <div class="exercise-block"><h4>Exercise:</h4><p>List <code>List&lt;dynamic&gt; mixedItems</code>. Iterate, print <code>runtimeType</code>. Use <code>is</code> to check for <code>int</code> and <code>String</code>. </p></div>`
          },
          {
            id: "data-immutable-class-m8",
            title: "8.13 Dart Data Class and Immutable Class",
            content: `
                <p>Dart doesn't have a built-in "data class" keyword.  Conceptually, a class primarily holding data. </p>
                <h4>Typical features for data/immutable classes:</h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li>All fields <code>final</code> (for immutability). </li>
                    <li><code>const</code> constructor. </li>
                    <li>Implementations for <code>hashCode</code> and <code>operator ==</code> (for value equality). </li>
                    <li><code>toString()</code> method. </li>
                    <li><code>copyWith()</code> method for creating modified copies (for immutable classes). </li>
                </ul>
                <div class="code-block"><button class="copy-button">Copy</button><pre><code>class PointData {
  final double x, y;
  const PointData(this.x, this.y); // 
  @override bool operator ==(Object other) => other is PointData && other.x == x && other.y == y; // 
  @override int get hashCode => x.hashCode ^ y.hashCode; // 
  @override String toString() => 'PointData(x: \$x, y: \$y)'; // 
  PointData copyWith({double? x, double? y}) => PointData(x ?? this.x, y ?? this.y); // 
}
void main() {
  const p1 = PointData(1.0, 2.0); // 
  const p2 = PointData(1.0, 2.0);
  print('p1 == p2: \${p1 == p2}'); // true 
  print('identical(p1, p2): \${identical(p1, p2)}'); // true 
}</code></pre></div>
                <p>Packages like <code>freezed</code> or <code>equatable</code> help generate this boilerplate. </p>
                <h4>Immutability: </h4>
                <p>State cannot change after creation. Achieved by: all fields <code>final</code>, contained objects also immutable (or defensive copies), no state-modifying methods. </p>
                <p><strong>Benefits:</strong> Simpler reasoning, thread safety, reliable <code>hashCode</code>, easier change detection. </p>
                <div class="exercise-block"><h4>Exercise:</h4><p>Immutable <code>BookDetails</code> class (final isbn, title, author, year). Implement <code>==</code>, <code>hashCode</code>, <code>toString()</code>, <code>copyWith()</code>. Test. </p></div>`
          },
          {
            id: "module8-practice-summary",
            title: "Module 8: Practice Questions Summary",
            isPractice: true,
            content: `
                <p>This completes Advanced OOP and Design Patterns.  Review exercises from sections 8.1 to 8.13. Focus on applying factory constructors, generics, common design patterns (Singleton, Builder, Prototype, Factory Method), understanding SOLID principles, and creating robust immutable data classes. </p>`
          }
        ]
      },
      module9: {
        title: "Module 9: Dart Asynchronous Programming",
        introduction: "Modern applications need to perform time-consuming operations (network, file I/O) without freezing. Asynchronous programming allows this. Dart's model uses Futures, Streams, and <code>async</code>/<code>await</code>. ",
        sections: [
          {
            id: "async-overview-m9",
            title: "9.1 Asynchronous Programming in Dart (Overview)",
            content: `
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong>Synchronous Operations:</strong> Execute one after another; program waits. [ Real-life: Single queue at a counter. [</li>
                    <li><strong>Asynchronous Operations:</strong> Start task, continue other code; notified on completion. [ Real-life: Ordering food at restaurant. ]</li>
                </ul>
                <p>Dart is single-threaded  and uses an event loop for concurrency (not true parallelism within one Isolate). [</p>`
          },
          {
            id: "future-async-ops-m9",
            title: "9.2 Future and Asynchronous Operations",
            content: `
                <p>A <code>Future&lt;T&gt;</code> represents a potential value (type T) or error available later.  It's a promise an operation will complete. </p>
                <h4>Future States:</h4>
                <ol class="list-decimal list-inside my-2 ml-4">
                    <li>Uncompleted: Operation not finished. </li>
                    <li>Completed with a value: Successful completion. </li>
                    <li>Completed with an error: Operation failed. </li>
                </ol>
                <h4>Creating a Future: </h4>
                <p>Many I/O functions return Futures.  Can also create manually.</p>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>import 'dart:async'; // For Timer, Completer 

// Simulating fetching user data
Future<String> fetchUserData(String userId) { // 
  print('Starting fetch for user: \$userId...');
  return Future.delayed(Duration(seconds: 2), () {
    if (userId == 'user123') return 'User Data for \$userId: {name: "Alice"}';
    throw Exception('User not found: \$userId'); // Completes with error 
  });
}

// Using Completer
Future<int> calculateComplexValue() { // 
  Completer<int> completer = Completer<int>(); // 
  Timer(Duration(seconds: 3), () {
    try {
      int result = 42 * 10;
      if (result < 0) throw Exception("Negative result!");
      completer.complete(result); // Complete with value 
    } catch (e) {
      completer.completeError(e); // Complete with error 
    }
  });
  return completer.future; // 
}

void main() {
  print('--- Futures ---');
  fetchUserData('user123') // 
    .then((data) => print('Success: \$data')) // Called on success 
    .catchError((error) => print('Error: \$error')) // Called on error 
    .whenComplete(() => print('Fetch for user123 finished.')); // Always called 
  
  fetchUserData('unknownUser') // 
    .then((data) => print('Success: \$data'))
    .catchError((error) => print('Error: \$error')); // 

  calculateComplexValue() // 
    .then((value) => print('Complex calc result: \$value'))
    .catchError((e) => print('Complex calc error: \$e'));
  print('Main function continues... (prints before Future results)'); // 
}</code></pre>
                </div>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><code>Future.delayed()</code>: Creates Future completing after delay. </li>
                    <li><code>.then((value) {...})</code>: Callback on successful completion. </li>
                    <li><code>.catchError((error) {...})</code>: Callback on error. </li>
                    <li><code>.whenComplete(() {...})</code>: Callback on completion (success or error), for cleanup. </li>
                </ul>`
          },
          {
            id: "async-await-keywords-m9",
            title: "9.3 await and async Keywords",
            content: `
                <p><code>async</code> and <code>await</code> provide a more readable, synchronous-looking way to write asynchronous code, avoiding "callback hell". </p>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong><code>async</code>:</strong> Marks a function as asynchronous.  Automatically returns a <code>Future</code>.  If returns <code>T</code>, it's <code>Future&lt;T&gt;</code>; if <code>void</code>, it's <code>Future&lt;void&gt;</code>. </li>
                    <li><strong><code>await</code>:</strong> Can only be used inside an <code>async</code> function.  Pauses execution of the <code>async</code> function until the <code>Future</code> completes.  Returns the Future's value if successful, or throws error if Future fails. </li>
                </ul>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>Future<String> fetchUserDataAsync(String userId) { // 
  print('Async: Starting fetch for: \$userId...');
  return Future.delayed(Duration(seconds: 2), () { // 
    if (userId == 'user123') return 'Async User Data for \$userId: {name: "Bob"}';
    if (userId == 'errorUser') throw Exception('Async: Simulated error for \$userId');
    throw Exception('Async: User not found: \$userId');
  });
}

Future<void> processUserData() async { // 
  print('processUserData: Started.');
  try {
    String userData1 = await fetchUserDataAsync('user123'); // Pauses here 
    print('processUserData: Received: \$userData1');
    // String userData2 = await fetchUserDataAsync('anotherUser'); // Would fail 
  } catch (e) {
    print('processUserData: Caught error: \$e'); // 
  } finally {
    print('processUserData: Processing attempt finished.'); // 
  }
}

Future<void> processMultipleData() async { // 
  try {
    // Concurrent fetching with Future.wait
    List<String> results = await Future.wait([ // 
        fetchUserDataAsync('user123'),
        fetchUserDataAsync('errorUser').catchError((e) => 'Handled: \$e'), // 
    ]);
    print('processMultipleData: All results/errors: \$results');
    // Sequential fetching also possible
  } catch (e) {
    print('processMultipleData: Error in Future.wait: \$e'); // 
  }
}

Future<void> main() async { // main marked async 
  await processUserData(); // 
  await processMultipleData(); // 
  print('Main: All async ops in main complete.'); // 
}</code></pre>
                </div>
                <p><code>try-catch</code> blocks naturally handle errors from <code>await</code>ed Futures.  <code>Future.wait(listOfFutures)</code> waits for all Futures to complete.  It returns a Future that completes with a list of results, or an error if any input Future fails. </p>
                <div class="real-life-example">
                    <h4>Real-life Example (async/await):</h4>
                    <p>Baking a cake: <code>async bakeCake()</code> -> <code>await preheatOven()</code> -> <code>await mixIngredients()</code> -> <code>await bakeInOven()</code>. Each step awaits completion.</p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <ol class="list-decimal list-inside space-y-1">
                        <li>Async function <code>getUserProfile(String userId)</code>: delay 1s. If "id001", return profile map; if "error", throw Exception. </li>
                        <li>In <code>async main</code>, call for "id001" and "error" with <code>await</code> and <code>try-catch</code>. Print results/errors. </li>
                    </ol>
                </div>`
          },
          {
            id: "streams-m9",
            title: "9.4 Stream and Stream Builders",
            content: `
                <p>A <code>Future</code> is one value; a <code>Stream</code> is a sequence of asynchronous events (data/errors). Listen to react as events arrive. </p>
                <h4>Key Concepts: </h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong>Sequence of Events:</strong> Zero or more data events, optionally one error or one "done" event. </li>
                    <li><strong>Listening:</strong> Subscribe (<code>listen</code>) to receive events. </li>
                    <li><strong>Types of Streams:</strong> 
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><strong>Single-subscription:</strong> Only one listener. For events like file reading. </li>
                            <li><strong>Broadcast:</strong> Multiple listeners. For general events (e.g., clicks). </li>
                        </ul>
                    </li>
                </ul>
                <h4>Creating and Using Streams: </h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>import 'dart:async';

// Stream-generating function (async*)
Stream<int> countNumbers(int maxCount) async* { // 
  print('Number counting stream started.');
  for (int i = 1; i <= maxCount; i++) { // 
    await Future.delayed(Duration(milliseconds: 500));
    yield i; // 'yield' emits a value 
    // if (i == maxCount -1 && maxCount > 4) throw Exception('Error!'); // 
  }
  print('Number counting stream finished.'); // 
}

// Broadcast stream with StreamController
Stream<String> getBroadcastMessages() { // 
  final controller = StreamController<String>.broadcast();
  Timer(Duration(seconds: 1), () => controller.add("Broadcast: Msg 1")); // 
  // controller.addError(Exception("Simulated stream error!")); // 
  Timer(Duration(seconds: 3), () => controller.close()); // Important to close 
  return controller.stream;
}

Future<void> main() async {
  Stream<int> numberStream = countNumbers(5); // 
  StreamSubscription<int>? sub1;
  sub1 = numberStream.listen( // 
    (number) => print('Received: \$number'),
    onError: (error) => print('Error in stream: \$error'),
    onDone: () => print('Number stream done.'),
    cancelOnError: false // 
  );
  // sub1?.pause(); sub1?.resume(); 

  Stream<String> broadcastStream = getBroadcastMessages(); // 
  broadcastStream.listen((msg) => print('Listener 1: \$msg')); // 
  await Future.delayed(Duration(milliseconds: 1500)); // 
  broadcastStream.listen((msg) => print('Listener 2 (late): \$msg')); // 

  // Using await for (processes events sequentially) 
  print('\\nUsing await for:');
  try {
    await for (int value in countNumbers(3)) { // 
      print('Await for received: \$value');
    }
  } catch (e) { print('Error in await for: \$e'); } // 
  
  await Future.delayed(Duration(seconds:4)); // Keep main alive for broadcast 
}</code></pre>
                </div>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><code>async*</code>: Marks a stream-generating function. </li>
                    <li><code>yield</code>: Emits a value into the stream in <code>async*</code> functions. </li>
                    <li><code>yield*</code>: Emits all values from another stream. </li>
                    <li><code>stream.listen()</code>: Subscribes with <code>onData</code>, <code>onError</code>, <code>onDone</code> callbacks. Returns <code>StreamSubscription</code> to pause/resume/cancel. </li>
                    <li><code>StreamController</code>: Programmatically create/manage streams. Use <code>.sink.add()</code>, <code>.sink.addError()</code>, <code>.sink.close()</code>. </li>
                    <li><code>await for</code>: Convenient loop for stream events. </li>
                </ul>
                <p>In Flutter, <code>StreamBuilder</code> widget listens to a Stream and rebuilds UI on new data.  It uses <code>AsyncSnapshot</code> for state. </p>
                <div class="real-life-example">
                    <h4>Real-life Example (Stream):</h4>
                    <p>Live news feed, mouse clicks, stock market ticker. </p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <ol class="list-decimal list-inside space-y-1">
                        <li><code>Stream&lt;String&gt; characterStream(String text)</code>: yields each char with 200ms delay. </li>
                        <li>In <code>main</code>, listen and print each char. </li>
                        <li>Use <code>onDone</code> to print "All characters emitted." </li>
                    </ol>
                </div>`
          },
          {
            id: "event-loop-m9",
            title: "9.5 Dart Event Loop and Microtask Queue",
            content: `
                <p>Dart is single-threaded.  It uses an event loop with two queues for asynchronous operations: </p>
                <ol class="list-decimal list-inside my-2 ml-4">
                    <li><strong>Main Execution:</strong> <code>main()</code> runs synchronous code. </li>
                    <li><strong>Scheduling Async Tasks:</strong> Async ops handled by system, schedule event on completion. </li>
                    <li><strong>Event Loop:</strong> Constantly picks events from queues and executes callbacks. </li>
                    <li><strong>Microtask Queue:</strong> 
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li>Higher priority than event queue. </li>
                            <li>Processed completely before event queue. </li>
                            <li>For short, immediate actions (e.g., internal <code>Future</code> completions, <code>scheduleMicrotask()</code>). </li>
                            <li><strong>Caution:</strong> Long microtasks can starve event queue, make app unresponsive. </li>
                        </ul>
                    </li>
                    <li><strong>Event Queue:</strong> 
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li>Events from I/O, timers, user interactions, Isolate messages. </li>
                            <li>Event loop takes one event, executes, then re-checks microtask queue. </li>
                        </ul>
                    </li>
                </ol>
                <h4>Order of Execution: </h4>
                <ol class="list-decimal list-inside my-2 ml-4">
                    <li>Current synchronous code.</li>
                    <li>All microtasks.</li>
                    <li>One event from event queue.</li>
                    <li>Repeat 2 & 3. </li>
                </ol>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>import 'dart:async';
void main() {
  print('Main: Start'); // 1 
  scheduleMicrotask(() => print('Microtask 1 Executed')); // 3 
  Future.delayed(Duration(seconds:0), () { // Event Queue (even with 0s delay) 
    print('Event: Future.delayed (0s) Executed'); // 7 (approx)
    scheduleMicrotask(() => print('Microtask 3 (after 0s Future)')); // 8
  });
  Future(() => { // Event Queue 
    print('Event: Future() 1 Executed'); // 5
    scheduleMicrotask(() => print('Microtask 2 (after Future 1)')); // 6
  });
  Future(() => print('Event: Future() 2 Executed')); // 9 (approx) 
  scheduleMicrotask(() => print('Microtask 1.1 Executed')); // 4 
  print('Main: End'); // 2 
  // Expected: Main Start, Main End, Microtask 1, Microtask 1.1, Event Future() 1, Microtask 2, Event Future.delayed, Microtask 3, Event Future() 2 
}</code></pre>
                </div>
                <p><code>scheduleMicrotask(callback)</code> explicitly schedules for microtask queue. </p>
                <div class="real-life-example">
                    <h4>Real-life Example:</h4>
                    <p>Chef (single thread): Sync tasks (chopping). Microtask queue (urgent notes like "wipe counter"). Event queue (order slips from waiters). </p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <p>Print "A", schedule microtask "B", Future "C", microtask "D", print "E". Predict output. </p>
                </div>`
          },
          {
            id: "async-exception-handling-m9",
            title: "9.6 Asynchronous Exception Handling (Consolidated)",
            content: `
                <p>Crucial for robust async code. </p>
                <h4>With <code>async/await</code>:</h4>
                <p>Use standard <code>try-catch-finally</code> blocks. </p>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>Future<String> riskyOperation(bool shouldFail) async { // 
  await Future.delayed(Duration(milliseconds: 100));
  if (shouldFail) throw Exception('Risky op failed!');
  return 'Risky op success!'; // 
}
Future<void> performTask() async { // 
  try { String result = await riskyOperation(true); print('Success: \$result'); } // 
  catch (e) { print('Caught: \$e'); } // 
  finally { print('Cleanup.'); } // 
}
// void main() async => await performTask(); // </code></pre>
                </div>
                <h4>With <code>Future.then().catchError()</code>: </h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>Future<String> anotherRiskyOp(bool fail) { // 
  return Future.delayed(Duration(milliseconds: 100), () {
    if (fail) throw Exception('Failure in anotherRiskyOp!');
    return 'Another success!'; // 
  });
}
void main() {
  anotherRiskyOp(true) // 
    .then((result) { print('Success: \$result'); /* throw Exception("Error in .then!"); */ }) // 
    .catchError((error) { print('Caught: \$error'); /* return "Recovered"; */ }) // 
    .then((valAfterError) { if (valAfterError != null) print("After handling: \$valAfterError"); }) // 
    .whenComplete(() => print('Attempt finished.')); // 
}</code></pre>
                </div>
                <div class="important-note"><p>An error thrown inside a <code>.then()</code> callback is not caught by a <code>.catchError()</code> chained before that <code>.then()</code>. </p></div>
                <h4>Errors in Streams:</h4>
                <p>Handle with <code>onError</code> in <code>listen()</code> or <code>try-catch</code> around <code>await for</code>. </p>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>Stream<int> streamWithError(int count) async* { // 
  for (int i = 1; i <= count; i++) {
    await Future.delayed(Duration(milliseconds: 10));
    if (i == 3) throw Exception('Error at item 3!'); // 
    yield i; // 
  }
}
// main() async {
//   streamWithError(5).listen( (data) => print('Data: \$data'), onError: (e) => print('Listen error: \$e') ); // 
//   try { await for (final data in streamWithError(5)) print('Await for data: \$data'); } // 
//   catch (e) { print('Await for error: \$e'); } // 
// }</code></pre>
                </div>
                <p>Unhandled asynchronous errors can crash apps.  Dart's <code>Zone</code> can be used for global error handling. </p>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <p>Modify <code>characterStream</code> from 9.4 to throw if input text is empty.  Handle error with <code>listen().onError</code> and <code>await for</code> in <code>try-catch</code>. </p>
                </div>`
          },
          {
            id: "streamcontroller-m9",
            title: "9.7 Using StreamController",
            content: `
                <p><code>StreamController</code> provides a way to create and manage a stream programmatically.  Add data/errors to its "sink", emitted to listeners on its "stream". </p>
                <h4>Key aspects: </h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><code>StreamController&lt;T&gt;()</code>: For single-subscription stream. </li>
                    <li><code>StreamController&lt;T&gt;.broadcast()</code>: For broadcast stream (multiple listeners). </li>
                    <li><code>controller.stream</code>: The Stream listeners subscribe to. </li>
                    <li><code>controller.sink</code>: <code>StreamSink</code> to add events. 
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li><code>sink.add(data)</code> </li>
                            <li><code>sink.addError(error, [stackTrace])</code> </li>
                            <li><code>sink.close()</code>: Closes stream, triggers <code>onDone</code>. </li>
                        </ul>
                    </li>
                    <li>Lifecycle Callbacks (single-subscription mostly): <code>onListen</code>, <code>onPause</code>, <code>onResume</code>, <code>onCancel</code> (for cleanup). </li>
                </ul>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>import 'dart:async';
class DataFeed { // 
  final _controller = StreamController<Map<String, dynamic>>.broadcast( // 
    onListen: () => print('DataFeed: First listener.'), // 
    onCancel: () => print('DataFeed: No more listeners.') // 
  );
  Timer? _timer; int _count = 0; // 
  Stream<Map<String, dynamic>> get stream => _controller.stream; // 
  DataFeed() { print('DataFeed created. Broadcast: \${_controller.stream.isBroadcast}'); } // 

  void startEmittingData() { // 
    if (_timer?.isActive ?? false) return;
    _timer = Timer.periodic(Duration(seconds: 1), (timer) { // 
      _count++; var data = {'id': _count, 'val': (_count * 10.5).toStringAsFixed(2)}; // 
      if (_controller.isClosed) { timer.cancel(); return; } // 
      if (_count == 2) _controller.sink.addError(Exception('Simulated error!')); else _controller.sink.add(data); // 
      if (_count >= 3) { stopAndClose(); } // 
    });
  }
  void stopAndClose() { _timer?.cancel(); _timer=null; if (!_controller.isClosed) _controller.sink.close(); print('Feed stopped & closed.');} // 
  void dispose() { stopAndClose(); print('DataFeed disposed.'); } // 
}
// Usage in main (conceptual for brevity) 
// DataFeed myFeed = DataFeed();
// myFeed.stream.listen(...); myFeed.startEmittingData(); ... myFeed.dispose();</code></pre>
                </div>
                <div class="important-note"><strong>Important:</strong> Always <code>close()</code> StreamControllers when no longer needed to release resources and signal <code>onDone</code>.  Cancel <code>StreamSubscription</code>s. </div>
                <div class="real-life-example">
                    <h4>Real-life Example:</h4>
                    <p>Radio station (<code>StreamController</code>). DJ (<code>sink.add</code>) broadcasts songs/announcements (data/errors) on airwaves (stream). Listeners tune in. </p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <p><code>SensorDataService</code> with <code>StreamController&lt;double&gt;.broadcast()</code> for temperature readings. Methods <code>startReading()</code> (periodic random values), <code>stopReading()</code>, <code>dispose()</code>. Test with two listeners. </p>
                </div>`
          },
          {
            id: "isolates-m9",
            title: "9.8 Isolate and Parallel Programming",
            content: `
                <p>Dart is single-threaded, using an event loop for concurrency.  For true parallelism (on different CPU cores), Dart provides Isolates. </p>
                <h4>Key Concepts of Isolates: </h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong>Independent Workers:</strong> Each Isolate has its own memory heap and event loop.  No direct memory sharing. </li>
                    <li><strong>No Shared State:</strong> Avoids common concurrency issues (race conditions, deadlocks). </li>
                    <li><strong>Communication via Ports:</strong> Pass messages through <code>SendPort</code> (to send) and <code>ReceivePort</code> (to receive, it's a Stream). </li>
                    <li><strong>CPU-Bound Tasks:</strong> Ideal for CPU-intensive computations (math, image processing, large JSON parsing) that would block UI isolate. </li>
                    <li><strong>Entry Point:</strong> Must be a top-level function or static method.  Cannot be a closure capturing scope variables. </li>
                </ul>
                <h4>Using Isolates: </h4>
                <p><code>Isolate.spawn(entryPointFunction, initialMessage)</code> creates a new isolate.  <code>initialMessage</code> often includes a <code>SendPort</code> for replies. </p>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>import 'dart:isolate'; import 'dart:async';

// Isolate entry point function 
void complexCalculationIsolate(dynamic initialMessage) { // 
  SendPort mainIsolateSendPort;
  int inputNumber = 0;
  if (initialMessage is Map && initialMessage.containsKey('replyPort') && initialMessage.containsKey('input')) { // 
    mainIsolateSendPort = initialMessage['replyPort'] as SendPort; // 
    inputNumber = initialMessage['input'] as int; // 
  } else { print('[Isolate]: Invalid initial message.'); return; } // 

  print('[Isolate \${Isolate.current.debugName}]: Started with input \$inputNumber.'); // 
  int fib(int n) => (n < 2) ? n : fib(n-2) + fib(n-1); // CPU-intensive task 
  try {
    int result = fib(inputNumber);
    mainIsolateSendPort.send({'status': 'success', 'result': result}); // Send result 
  } catch (e, s) {
    mainIsolateSendPort.send({'status': 'error', 'error': e.toString(), 'stackTrace': s.toString()}); // 
  } finally { print('[Isolate]: Work complete.'); /* Isolate exits if not killed */ } // 
}

Future<void> main() async {
  final receivePort = ReceivePort(); // For main isolate 
  final initialMessage = {'replyPort': receivePort.sendPort, 'input': 38 }; // 
  Isolate? workerIsolate; StreamSubscription? portSub; // 
  try {
    workerIsolate = await Isolate.spawn(complexCalculationIsolate, initialMessage); // 
    final resultCompleter = Completer<int>(); // 
    portSub = receivePort.listen((dynamic msg) { // 
      if (msg is Map) {
        if (msg['status'] == 'success') resultCompleter.complete(msg['result']);
        else if (msg['status'] == 'error') resultCompleter.completeError(Exception(msg['error']));
      }
    });
    for (int i=0; i<2; i++) { print('[Main]: Other work \$i'); await Future.delayed(Duration(milliseconds:100));} // 
    int fibResult = await resultCompleter.future.timeout(Duration(seconds:20)); // 
    print('[Main]: Fibonacci result: \$fibResult'); // 
  } catch (e) { print('[Main]: Error: \$e'); } // 
  finally { portSub?.cancel(); receivePort.close(); workerIsolate?.kill(); print('[Main]: Cleanup.'); } // 
}</code></pre>
                </div>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li>Messages between isolates must be simple types or <code>SendPort</code>s (complex objects copied). </li>
                    <li><code>isolate.kill()</code> terminates an isolate. </li>
                </ul>
                <p>Flutter's <code>compute(function, argument)</code> simplifies offloading single computations. </p>
                <h4>When to use Isolates:</h4>
                <p>For CPU-bound tasks that would make UI janky. Not typically for I/O-bound tasks (handled well by Futures/async). </p>
                <div class="real-life-example">
                    <h4>Real-life Example:</h4>
                    <p>Company (main app) has separate factory (Isolate) for complex components, working in parallel. </p>
                </div>
                <div class="exercise-block">
                    <h4>Exercise:</h4>
                    <ol class="list-decimal list-inside space-y-1">
                        <li>Top-level <code>List&lt;int&gt; findPrimeNumbers(int limit)</code>. </li>
                        <li>In <code>main</code>, use <code>Isolate.spawn()</code> for <code>findPrimeNumbers</code>. </li>
                        <li>Use <code>ReceivePort</code> for results, print count. </li>
                        <li>Ensure cleanup.  (Optional: try Flutter's <code>compute()</code>). </li>
                    </ol>
                </div>`
          },
          {
            id: "module9-practice-summary",
            title: "Module 9: Practice Questions Summary",
            isPractice: true,
            content: `
                <p>This completes Dart Asynchronous Programming.  Review concepts of Futures, Streams, async/await, the Event Loop, StreamControllers, and Isolates.  Next is Advanced Debugging. </p>`
          }
        ]
      },
      module10: { // Corresponds to PDF Module 10
        title: "Module 10: Advanced Debugging",
        introduction: "Debugging is finding and fixing errors.  Effective debugging is crucial.  This module covers advanced tools and techniques beyond simple <code>print()</code> statements. ",
        sections: [
          {
            id: "debugging-overview-m10",
            title: "10.1 Dart Debugging (Overview)",
            content: `
                <p>Debugging involves: </p>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li>Understanding the Problem. </li>
                    <li>Reproducing the Bug. </li>
                    <li>Isolating the Cause. </li>
                    <li>Fixing the Bug. </li>
                    <li>Verifying the Fix. </li>
                </ul>
                <p>Dart has excellent debugging support. </p>`
          },
          {
            id: "debugging-tools-m10",
            title: "10.2 Dart Debugging Tools",
            content: `
                <p>Primary debugging tools for Dart (and Flutter): </p>
                <ol class="list-decimal list-inside my-2 ml-4">
                    <li><strong>IDE Debuggers:</strong> 
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li>VS Code: Via Dart extension. </li>
                            <li>IntelliJ IDEA / Android Studio: Comprehensive features. </li>
                        </ul>
                        <p>Features: breakpoints, stepping, variable inspection, call stacks, evaluating expressions. </p>
                    </li>
                    <li><strong>Dart DevTools:</strong> Suite of performance/debugging tools (web-based).  Features include: 
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li>Flutter Inspector (Flutter specific). </li>
                            <li>Debugger (similar to IDEs). </li>
                            <li>Logging View. </li>
                            <li>Network Profiler. </li>
                            <li>Performance Profiler (CPU). </li>
                            <li>Memory Profiler. </li>
                            <li>App Size Tool. </li>
                        </ul>
                    </li>
                    <li><strong>Command-line Debugger:</strong> <code>dart debug</code>. </li>
                    <li><strong><code>print()</code> statements:</strong> Simple but effective. </li>
                    <li><strong><code>debugger()</code> statement:</strong> Programmatically triggers breakpoint if debugger attached (<code>import 'dart:developer';</code>). </li>
                </ol>`
          },
          {
            id: "flutter-modes-m10",
            title: "10.3 Flutter Debug Mode and Release Mode",
            content: `
                <p>(Flutter-specific, but important context for Dart developers). </p>
                <p>Flutter apps compile in different modes:</p>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong>Debug Mode:</strong> 
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li>For rapid development/debugging. </li>
                            <li>Enables assertions (<code>assert()</code>). </li>
                            <li>Includes debug info, hot reload/restart. </li>
                            <li>Service extensions (for DevTools) enabled. </li>
                            <li>Performance not representative (slower, larger app). </li>
                        </ul>
                    </li>
                    <li><strong>Profile Mode:</strong> 
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li>For performance analysis with some debug capabilities. </li>
                            <li>Assertions disabled.  Service extensions enabled. </li>
                            <li>Aims for release-like performance.  Used for diagnosing jank. </li>
                        </ul>
                    </li>
                    <li><strong>Release Mode:</strong> 
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li>Optimized for performance and size. </li>
                            <li>Assertions disabled. Debug info/service extensions stripped. </li>
                            <li>No hot reload/restart.  For deployment. </li>
                        </ul>
                    </li>
                </ul>
                <p><strong>Why this matters:</strong> Debug mode has richest tools.  <code>assert()</code> only runs in debug mode. </p>`
          },
          {
            id: "print-debugging-m10",
            title: "10.4 Dart print() Statement Debugging",
            content: `
                <p>Simplest form: insert <code>print()</code> to output variable values, trace flow, check conditions. </p>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>int factorialDebug(int n) {
  print('Calculating factorial for n = \$n'); // Trace entry 
  if (n <= 1) {
    print('Base case: n = \$n, returning 1'); // 
    return 1;
  }
  int result = n * factorialDebug(n - 1);
  print('Intermediate result for n = \$n: \$result'); // Trace intermediate 
  return result;
}</code></pre>
                </div>
                <p><strong>Pros:</strong> Quick, easy, works anywhere.  <strong>Cons:</strong> Clutters code, static (no interaction), tedious for complex bugs, output can be overwhelming. </p>
                <p><strong>Tips:</strong> Make prints informative. Remove/comment after. Consider logging packages. </p>`
          },
          {
            id: "debugger-breakpoints-m10",
            title: "10.5 Dart Debugger and Breakpoint Usage",
            content: `
                <p>More powerful for understanding issues. </p>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong>Breakpoint:</strong> Marker on code line. Pauses execution when reached. </li>
                    <li><strong>Stepping Controls:</strong> 
                        <ul class="list-disc list-inside my-2 ml-4">
                            <li>Step Over (F10): Executes current line, moves to next in same function. If line is function call, executes function without stepping into it. </li>
                            <li>Step Into (F11): If line is function call, moves into that function. Else, like Step Over. </li>
                            <li>Step Out (Shift+F11): Executes rest of current function, returns to call site. </li>
                            <li>Continue/Resume (F5/F8): Resumes until next breakpoint or end. </li>
                        </ul>
                    </li>
                    <li><strong>Variable Inspection:</strong> View current values of local, instance (<code>this</code>), global variables. </li>
                    <li><strong>Watch Expressions:</strong> Monitor expressions' values during stepping. </li>
                    <li><strong>Call Stack:</strong> Shows sequence of function calls to current point. </li>
                    <li><strong>Conditional Breakpoints:</strong> Trigger only if a condition is true (e.g., <code>i > 10</code>). </li>
                </ul>
                <p>Example Scenario (Conceptual - in IDE): Set breakpoint in a loop in <code>calculateSum(List&lt;int&gt; numbers)</code>. </p>
                <div class="exercise-block"><h4>Exercise:</h4><p>Debug <code>factorialDebug</code> in IDE. Set breakpoint, step through recursive calls, observe call stack & variable <code>n</code>. Set conditional breakpoint for <code>n == 1</code>. </p></div>`
          },
          {
            id: "ide-debugging-m10",
            title: "10.6 Dart Debugging in VS Code and IntelliJ",
            content: `
                <p>Both VS Code (Dart extension) and IntelliJ IDEA/Android Studio (Dart plugin) offer excellent integrated debugging.</p>
                <h4>Common Features: </h4>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li>Run/Debug Configurations & Views. </li>
                    <li>Debug Toolbars/Windows (Frames/Call Stack, Variables, Watches, Console). </li>
                    <li>Setting Breakpoints (click in gutter), Conditional Breakpoints. </li>
                    <li>Logpoints (Expression Breakpoints): Log message/expression value and continue. </li>
                    <li>Exception Breakpoints: Pause on thrown exceptions (caught or uncaught). </li>
                </ul>`
          },
          {
            id: "logging-console-m10",
            title: "10.7 Dart Logging and Console Output",
            content: `
                <p>For complex apps, dedicated logging is better than <code>print()</code>. </p>
                <h4><code>dart:developer</code>'s <code>log()</code> function: </h4>
                <p>More structured, integrates with Dart DevTools.  Allows specifying name, level, error object, etc. </p>
                <div class="code-block"><button class="copy-button">Copy</button><pre><code>import 'dart:developer' as developer; // 
void processItem(int itemId) {
  developer.log('Starting process.', name: 'processor', level: 800); // 
  // ...
}</code></pre></div>
                <h4>Logging Packages (e.g., <code>package:logging</code>): </h4>
                <p>Advanced features: hierarchical loggers, configurable levels, multiple handlers, formatting. </p>
                <p>Dart DevTools "Logging" view shows <code>print()</code>, <code>developer.log()</code>, framework logs. </p>
                <div class="exercise-block"><h4>Exercise:</h4><p>Modify a function to use <code>developer.log()</code> with different names/levels. </p></div>`
          },
          {
            id: "exception-debugging-m10",
            title: "10.8 Dart Exception Handling and Debugging",
            content: `
                <p>Debugging exceptions involves: </p>
                <ol class="list-decimal list-inside my-2 ml-4">
                    <li>Understanding Exception: Message and type. </li>
                    <li>Stack Trace: Sequence of calls leading to exception. Crucial for origin. </li>
                    <li>Debugger for Exceptions: IDEs can break on "All Exceptions" or "Uncaught Exceptions" (often most useful).</li>
                    <li>Inspecting Variables: When paused, check variable values in scope and call stack. </li>
                </ol>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code>void checkAge(int? age) { // 
  try {
    if (age == null) throw ArgumentError.notNull('age'); // 
    if (age < 0) throw FormatException('Age cannot be negative.', age.toString()); // 
    print(age < 18 ? 'Minor' : 'Adult'); // 
  } on FormatException catch (e, s) { print('FormatException: \${e.message}'); /* print stack trace s */ } // 
  catch (e, s) { print('Other error: \$e'); /* print stack trace s */ } // 
}
// main() { checkAge(-5); checkAge(null); } </code></pre></div>
                <div class="exercise-block"><h4>Exercise:</h4><p>Function accessing invalid list index. Wrap in try-catch. Debug with break on uncaught/all exceptions. Print exception object & runtimeType. </p></div>`
          },
          {
            id: "async-future-debugging-m10",
            title: "10.9 Dart Asynchronous and Future Debugging",
            content: `
                <p>Debugging async code (Futures, Streams, async/await) can be trickier due to non-sequential flow. </p>
                <ul class="list-disc list-inside my-2 ml-4">
                    <li><strong>IDE Debugger Support:</strong> Good for <code>async/await</code>. Breakpoints in async functions work. </li>
                    <li><strong>Call Stack for Async:</strong> May include "async gap" frames. DevTools/IDEs try to show "causal" async stack. </li>
                    <li><strong>Debugging <code>.then().catchError()</code>:</strong> Breakpoints in callbacks work, but flow harder to follow. </li>
                    <li><strong>Debugging Streams:</strong> Set breakpoints in <code>listen()</code> callbacks, <code>async*</code> functions, or <code>await for</code> loops. </li>
                    <li><strong>Dart DevTools:</strong> Logging, Debugger, Timeline/Performance, Flutter Inspector. </li>
                </ul>
                <h4>Tips for Debugging Async Code:</h4>
                <ol class="list-decimal list-inside my-2 ml-4">
                    <li>Use <code>async/await</code> for readability. </li>
                    <li>Thorough logging (<code>developer.log()</code>). </li>
                    <li>Explicit error handling (<code>try-catch</code> or <code>.catchError()</code>). </li>
                    <li>Break down complex async flows. </li>
                    <li>Understand the Event Loop. </li>
                    <li>Use <code>.timeout()</code> for Futures that might not complete. </li>
                </ol>
                <div class="code-block"><button class="copy-button">Copy</button><pre><code>Future<String> fetchDataWithTimeout() async { // 
  try {
    return await someNetworkCall().timeout(Duration(seconds: 5), // 
      onTimeout: () => throw TimeoutException('Network call timed out!')); // 
  } on TimeoutException catch(e) { return 'Default data due to timeout'; } // 
  catch (e) { return 'Default data due to error'; } // 
}
// Future<String> someNetworkCall() => Future.delayed(Duration(seconds: 2), () => "Actual Data"); // </code></pre></div>
                <div class="exercise-block"><h4>Exercise:</h4><p>Debug an async <code>getUserProfile()</code> function. Call multiple times. Set breakpoints at start, before/after <code>await Future.delayed()</code>, return/throw lines, and in <code>catch</code> block in <code>main</code>. Step through, observe call stack. </p></div>`
          },
          {
            id: "module10-practice-summary",
            title: "Module 10: Practice Questions Summary",
            isPractice: true,
            content: `<p>This completes Advanced Debugging. Review exercises focusing on using IDE debuggers for both synchronous and asynchronous code, effective exception handling analysis, and leveraging logging. Understanding these tools and techniques is vital for efficient Dart development.</p>`
          }
        ]
      },
      nextsteps: {
        title: "🚀 What's Next? Continue Your Dart Adventure!",
        introduction: "Congratulations on working through these Dart modules! You've built a strong foundational understanding of the Dart language, from basic syntax to advanced concepts like OOP, asynchronous programming, and design patterns. The journey doesn't stop here. Here are some suggestions and resources to help you continue learning, practicing, and building amazing things with Dart.",
        sections: [
          {
            id: "practice-reinforce",
            title: "1. Practice, Practice, Practice! 💻",
            content: `
                <p>The most crucial step now is to solidify your knowledge by writing a lot of Dart code. The more you practice, the more comfortable and proficient you'll become.</p>
                <ul class="list-disc list-inside my-2 ml-4 space-y-1">
                    <li><strong>Coding Challenges:</strong>
                        <ul class="list-disc list-inside ml-6 space-y-1">
                            <li><a href="https://www.hackerrank.com/domains/tutorials/10-days-of-dart" target="_blank" class="text-blue-600 hover:underline">HackerRank (10 Days of Dart)</a>: A good starting point for structured challenges.</li>
                            <li><a href="https://www.codewars.com/?language=dart" target="_blank" class="text-blue-600 hover:underline">Codewars (Dart Katas)</a>: Solve progressively harder coding challenges (katas).</li>
                            <li><a href="https://leetcode.com/problemset/all/?topicSlugs=dart" target="_blank" class="text-blue-600 hover:underline">LeetCode (Dart problems)</a>: For more advanced data structures and algorithm practice.</li>
                            <li><a href="https://exercism.org/tracks/dart" target="_blank" class="text-blue-600 hover:underline">Exercism (Dart Track)</a>: Get mentored on your solutions to coding exercises.</li>
                        </ul>
                    </li>
                    <li><strong>Revisit Exercises:</strong> Go back through the exercises in this tutorial. Try to solve them again without looking at the solutions first, or try to find alternative solutions.</li>
                    <li><strong>Extend Examples:</strong> Take the code examples provided in the modules and try to extend them with new features or variations.</li>
                </ul>`
          },
          {
            id: "build-projects",
            title: "2. Build Small to Medium-Sized Projects 🛠️",
            content: `
                <p>Applying your knowledge to build projects is the best way to learn how different concepts fit together and to encounter real-world problems.</p>
                <h4>Beginner-Friendly Project Ideas (Console-based):</h4>
                <ul class="list-disc list-inside my-2 ml-4 space-y-1">
                    <li><strong>To-Do List Application:</strong> Manage tasks (add, remove, mark complete, list). Focus on collections and basic I/O (if using files, covered in Module 5).</li>
                    <li><strong>Simple Calculator:</strong> Handle basic arithmetic operations. Focus on functions and conditional logic.</li>
                    <li><strong>Text-Based Adventure Game:</strong> Create rooms, items, and simple interactions. Focus on OOP (classes for rooms, items, player) and control flow.</li>
                    <li><strong>Contact Book:</strong> Store names, phone numbers, emails. Focus on Maps and OOP.</li>
                    <li><strong>Unit Converter:</strong> Convert between different units (e.g., Celsius to Fahrenheit, kg to lbs). Focus on functions and data types.</li>
                </ul>
                <h4>Next Steps (Consider these after mastering console apps):</h4>
                <ul class="list-disc list-inside my-2 ml-4 space-y-1">
                    <li><strong>Simple API Client:</strong> Fetch data from a public API (e.g., a weather API, a joke API) and display it. (Module 9: Async Programming)</li>
                </ul>`
          },
          {
            id: "deepen-dart-knowledge",
            title: "3. Deepen Your Dart Knowledge 📚",
            content: `
                <p>Explore more advanced Dart features and libraries:</p>
                <ul class="list-disc list-inside my-2 ml-4 space-y-1">
                    <li><strong>Official Dart Documentation:</strong>
                        <ul class="list-disc list-inside ml-6 space-y-1">
                            <li><a href="https://dart.dev/guides" target="_blank" class="text-blue-600 hover:underline">Dart Language Tour</a>: A comprehensive overview.</li>
                            <li><a href="https://dart.dev/guides/libraries" target="_blank" class="text-blue-600 hover:underline">Dart Core Library Documentation</a>: Understand built-in libraries like <code>dart:core</code>, <code>dart:async</code>, <code>dart:math</code>, <code>dart:convert</code>, and <code>dart:io</code> (for command-line/server).</li>
                            <li><a href="https://dart.dev/effective-dart" target="_blank" class="text-blue-600 hover:underline">Effective Dart</a>: Guidelines for writing clear, concise, and robust Dart code.</li>
                        </ul>
                    </li>
                    <li><strong>Packages:</strong> Explore useful packages on <a href="https://pub.dev" target="_blank" class="text-blue-600 hover:underline">pub.dev</a> (Dart's package manager). For example:
                        <ul class="list-disc list-inside ml-6 space-y-1">
                            <li><code>http</code>: For making HTTP requests.</li>
                            <li><code>intl</code>: For internationalization and localization.</li>
                            <li><code>path</code>: For platform-independent path manipulation.</li>
                            <li><code>collection</code>: More collection algorithms and classes.</li>
                            <li><code>equatable</code> / <code>freezed</code>: For simplifying data classes and immutability (Module 8).</li>
                        </ul>
                    </li>
                    <li><strong>Advanced Language Features:</strong> Revisit and practice topics from Modules 7, 8, and 9 like advanced OOP, design patterns, isolates, and streams in more depth.</li>
                </ul>`
          },
          {
            id: "learn-flutter",
            title: "4. Learn Flutter for App Development (Mobile, Web, Desktop) 📱💻🌐",
            content: `
                <p>If your goal is to build applications for mobile, web, or desktop, learning Flutter is a natural next step. Dart is the language that powers Flutter.</p>
                <ul class="list-disc list-inside my-2 ml-4 space-y-1">
                    <li><strong>Official Flutter Documentation:</strong> <a href="https://flutter.dev/docs" target="_blank" class="text-blue-600 hover:underline">flutter.dev/docs</a> is the best place to start.
                        <ul class="list-disc list-inside ml-6 space-y-1">
                            <li><a href="https://docs.flutter.dev/get-started/install" target="_blank" class="text-blue-600 hover:underline">Install Flutter</a></li>
                            <li><a href="https://docs.flutter.dev/get-started/codelab" target="_blank" class="text-blue-600 hover:underline">Write your first Flutter app</a> (Codelab)</li>
                            <li><a href="https://docs.flutter.dev/development/ui/widgets-intro" target="_blank" class="text-blue-600 hover:underline">Introduction to Widgets</a></li>
                        </ul>
                    </li>
                    <li><strong>Flutter YouTube Channel:</strong> <a href="https://www.youtube.com/flutterdev" target="_blank" class="text-blue-600 hover:underline">youtube.com/flutterdev</a> has many helpful series like "Widget of the Week" and "Flutter Boring Show."</li>
                    <li><strong>Online Courses:</strong> Platforms like Udemy, Coursera, freeCodeCamp, and others offer comprehensive Flutter courses.</li>
                </ul>
                <p>Your understanding of Dart (variables, control flow, functions, OOP, async) will be directly applicable and essential for Flutter development.</p>`
          },
          {
            id: "server-side-dart",
            title: "5. Explore Server-Side Dart ⚙️",
            content: `
                <p>Dart is not just for client-side applications. It's also a capable language for building backends.</p>
                <ul class="list-disc list-inside my-2 ml-4 space-y-1">
                    <li><strong><a href="https://dart.dev/server" target="_blank" class="text-blue-600 hover:underline">Dart Server Overview</a></strong></li>
                    <li><strong>Frameworks:</strong>
                        <ul class="list-disc list-inside ml-6 space-y-1">
                            <li><a href="https://pub.dev/packages/shelf" target="_blank" class="text-blue-600 hover:underline">Shelf</a>: A minimal, composable web server middleware and request handler.</li>
                            <li><a href="https://dartfrog.vg" target="_blank" class="text-blue-600 hover:underline">Dart Frog</a>: A fast, minimalistic backend framework for Dart built by Very Good Ventures.</li>
                            <li><a href="https://conduit.dart.dev/" target="_blank" class="text-blue-600 hover:underline">Conduit (formerly Aqueduct)</a>: A more full-featured server-side framework.</li>
                        </ul>
                    </li>
                </ul>`
          },
          {
            id: "community-contribution",
            title: "6. Join Communities & Contribute 🤝",
            content: `
                <p>Engaging with other developers can accelerate your learning and provide support.</p>
                <ul class="list-disc list-inside my-2 ml-4 space-y-1">
                    <li><strong>Online Communities:</strong>
                        <ul class="list-disc list-inside ml-6 space-y-1">
                            <li><a href="https://stackoverflow.com/questions/tagged/dart" target="_blank" class="text-blue-600 hover:underline">Stack Overflow (Dart tag)</a></li>
                            <li><a href="https://www.reddit.com/r/dartlang/" target="_blank" class="text-blue-600 hover:underline">Dart Subreddit (r/dartlang)</a></li>
                            <li><a href="https://www.reddit.com/r/FlutterDev/" target="_blank" class="text-blue-600 hover:underline">Flutter Subreddit (r/FlutterDev)</a></li>
                            <li>Various Discord servers (e.g., Flutter Community, Dart Community).</li>
                            <li><a href="https://medium.com/dartlang" target="_blank" class="text-blue-600 hover:underline">Dart Medium Publication</a></li>
                        </ul>
                    </li>
                    <li><strong>Contribute to Open Source:</strong> Find Dart or Flutter projects on <a href="https://github.com/topics/dart" target="_blank" class="text-blue-600 hover:underline">GitHub</a>. Contributing to open source is a great way to learn from experienced developers and build your portfolio.</li>
                </ul>`
          },
          {
            id: "stay-updated",
            title: "7. Stay Updated & Keep Learning 💡",
            content: `
                <p>The Dart and Flutter ecosystems are constantly evolving. Stay updated with the latest changes, features, and best practices.</p>
                <ul class="list-disc list-inside my-2 ml-4 space-y-1">
                    <li>Follow the <a href="https://medium.com/dartlang" target="_blank" class="text-blue-600 hover:underline">Official Dart Blog</a> and <a href="https://medium.com/flutter" target="_blank" class="text-blue-600 hover:underline">Flutter Blog</a>.</li>
                    <li>Watch for announcements at events like Google I/O and Flutter Engage.</li>
                    <li>Don't be afraid to dive into the source code of Dart SDK or popular packages to understand how things work under the hood.</li>
                </ul>
                <p class="mt-4 font-semibold">The most important thing is to keep coding, keep exploring, and enjoy the process of building amazing things with Dart! Good luck on your continued journey!</p>`
          }
        ]
      }
    };

    const contentArea = document.getElementById('content-area');
    const moduleNavigation = document.getElementById('module-navigation'); // Changed from dayNavigation
    const tooltip = document.getElementById('tooltip');
    let sectionsChartInstance = null;

    function renderContent(moduleKey) { // Changed from dayKey
      const moduleData = tutorialData[moduleKey]; // Changed from dayData
      if (!moduleData) {
        contentArea.innerHTML = '<p>Content not found.</p>';
        return;
      }

      let html = `<div class="content-section">`;
      html += `<h1 class="text-3xl font-bold mb-6">${moduleData.title}</h1>`;
      if (moduleData.introduction) {
        html += `<p class="text-lg text-gray-700 mb-6">${moduleData.introduction}</p>`;
      }
      html += moduleData.content || '';

      if (moduleData.sections) {
        moduleData.sections.forEach(section => {
          html += `<section id="${moduleKey}-${section.id}" class="mb-8">`;
          html += `<h2 class="text-2xl font-semibold mb-3">${section.title}</h2>`;
          if (section.isPractice) {
            html += `<div class="practice-questions">${section.content}</div>`;
          } else {
            html += `<div class="text-gray-800 leading-relaxed">${section.content}</div>`;
          }
          html += `</section>`;
        });
      }
      html += `</div>`;
      contentArea.innerHTML = html;
      contentArea.scrollTop = 0;

      document.querySelectorAll('.copy-button').forEach(button => {
        button.addEventListener('click', copyCodeBlock);
      });

      if (moduleKey === 'overview' && sectionsChartInstance) {
        sectionsChartInstance.destroy();
        sectionsChartInstance = null;
      }
      if (moduleKey === 'overview') {
        renderSectionsChart();
      }
    }

    function updateActiveLink(activeModuleKey) { // Changed from activeDayKey
      moduleNavigation.querySelectorAll('a').forEach(link => { // Changed from dayNavigation
        if (link.dataset.module === activeModuleKey) { // Changed from data-day
          link.classList.add('active');
        } else {
          link.classList.remove('active');
        }
      });
    }

    function copyCodeBlock(event) {
      const button = event.target;
      const codeBlock = button.closest('.code-block');
      const codeElement = codeBlock.querySelector('pre code');
      const codeToCopy = codeElement.innerText;

      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(codeToCopy).then(() => {
          showTooltip(button);
        }).catch(err => {
          console.warn('Async clipboard write failed, falling back:', err);
          fallbackCopyTextToClipboard(codeToCopy, button);
        });
      } else {
        fallbackCopyTextToClipboard(codeToCopy, button);
      }
    }

    function fallbackCopyTextToClipboard(text, button) {
      const textArea = document.createElement("textarea");
      textArea.value = text;
      textArea.style.top = "0";
      textArea.style.left = "0";
      textArea.style.position = "fixed";
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      try {
        const successful = document.execCommand('copy');
        if (successful) showTooltip(button);
        else alert('Failed to copy text. Please copy manually.');
      } catch (err) {
        alert('Failed to copy text. Please copy manually.');
      }
      document.body.removeChild(textArea);
    }

    function showTooltip(button) {
      tooltip.style.visibility = 'visible';
      tooltip.style.opacity = '1';
      const buttonRect = button.getBoundingClientRect();
      tooltip.style.left = `${buttonRect.left + (buttonRect.width / 2) - (tooltip.offsetWidth / 2)}px`;
      tooltip.style.top = `${buttonRect.top - tooltip.offsetHeight - 5}px`;
      setTimeout(() => {
        tooltip.style.visibility = 'hidden';
        tooltip.style.opacity = '0';
      }, 1500);
    }

    function renderSectionsChart() {
      const ctx = document.getElementById('sectionsChart')?.getContext('2d');
      if (!ctx) return;

      const moduleKeys = Object.keys(tutorialData).filter(key => key.startsWith('module')); // Changed from dayKeys
      const labels = moduleKeys.map(key => tutorialData[key].title.split(':')[0]);
      const data = moduleKeys.map(key => tutorialData[key].sections?.length || 0);

      sectionsChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Number of Main Sections',
            data: data,
            backgroundColor: 'rgba(74, 144, 226, 0.6)',
            borderColor: 'rgba(74, 144, 226, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: { beginAtZero: true, title: { display: true, text: 'Number of Sections' }, ticks: { stepSize: 1 } },
            x: {
              title: { display: true, text: 'Tutorial Module' }, ticks: {
                maxRotation: 0, minRotation: 0, callback: function (value) {
                  const label = this.getLabelForValue(value);
                  return label.length > 10 ? label.substring(0, 10) + '...' : label;
                }
              }
            }
          },
          plugins: {
            legend: { display: false }, tooltip: {
              enabled: true, backgroundColor: '#343A40', titleColor: '#F8F9FA', bodyColor: '#F8F9FA', callbacks: {
                title: (tooltipItems) => tooltipItems[0].label,
                label: (tooltipItem) => `Sections: ${tooltipItem.raw}`
              }
            }
          }
        }
      });
    }

    moduleNavigation.addEventListener('click', (event) => { // Changed from dayNavigation
      event.preventDefault();
      const link = event.target.closest('a');
      if (link && link.dataset.module) { // Changed from data-day
        const moduleKey = link.dataset.module; // Changed from dayKey
        renderContent(moduleKey);
        updateActiveLink(moduleKey);
        history.pushState({ module: moduleKey }, '', `#${moduleKey}`); // Changed from day
      }
    });

    window.addEventListener('popstate', (event) => {
      const moduleKey = (event.state && event.state.module) || window.location.hash.substring(1) || 'overview'; // Changed from day
      renderContent(moduleKey);
      updateActiveLink(moduleKey);
    });

    document.addEventListener('DOMContentLoaded', () => {
      const initialModule = window.location.hash.substring(1) || 'overview'; // Changed from initialDay
      renderContent(initialModule);
      updateActiveLink(initialModule);
      if (initialModule === 'overview') {
        renderSectionsChart();
      }
    });

  </script>
</body>

</html>